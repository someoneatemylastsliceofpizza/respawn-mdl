//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: mdl
//   Authors: Valve, Respawn, Rika, & Others
//   Version: 47/48/49/52/53
//   Purpose: Valve/Respawn MDL Structs
//  Category: Struct
// File Mask: *.mdl
//  ID Bytes: 
//   History: 
//------------------------------------------------

#define MAX_NUM_LODS 8
#define MAX_NUM_BONES_PER_VERT 3
//typedef Vector3 Vector;

//local int i = 0;

// these are just all structs that I have mostly working/fitting, it does not mean they are correct.
// a lot of these are from either valvedevwiki, the public source sdk 2013 code, and crowbar.


//========
// Headers


// header flags

// This flag is set if no hitbox information was specified
#define STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX	0x1

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_ENV_CUBEMAP		0x2

// Use this when there are translucent parts to the model but we're not going to sort it 
#define STUDIOHDR_FLAGS_FORCE_OPAQUE			0x4

// Use this when we want to render the opaque parts during the opaque pass
// and the translucent parts during the translucent pass
#define STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS		0x8

// This is set any time the .qc files has $staticprop in it
// Means there's no bones and no transforms
#define STUDIOHDR_FLAGS_STATIC_PROP				0x10

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_FB_TEXTURE		    0x20

// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
//  for the .mdl (the shadow lod is the last entry in the lod list if present)
#define STUDIOHDR_FLAGS_HASSHADOWLOD			0x40

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_BUMPMAPPING		0x80

// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
// instead of overriding them with the default one (necessary for translucent shadows)
#define STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS	0x100

// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
// instead of overriding them with the default one (necessary for translucent shadows)
#define STUDIOHDR_FLAGS_OBSOLETE				0x200

#define STUDIOHDR_FLAGS_UNUSED					0x400

// NOTE:  This flag is set at mdl build time
#define STUDIOHDR_FLAGS_NO_FORCED_FADE			0x800

// NOTE:  The npc will lengthen the viseme check to always include two phonemes
#define STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE	0x1000

// This flag is set when the .qc has $constantdirectionallight in it
// If set, we use constantdirectionallightdot to calculate light intensity
// rather than the normal directional dot product
// only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
#define STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT 0x2000

// Flag to mark delta flexes as already converted from disk format to memory format
#define STUDIOHDR_FLAGS_FLEXES_CONVERTED		0x4000

// Indicates the studiomdl was built in preview mode
#define STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE	0x8000

// Ambient boost (runtime flag)
#define STUDIOHDR_FLAGS_AMBIENT_BOOST			0x10000

// Don't cast shadows from this model (useful on first-person models)
#define STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS		0x20000

// alpha textures should cast shadows in vrad on this model (ONLY prop_static!)
#define STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS	0x40000

// Model has a quad-only Catmull-Clark SubD cage
#define STUDIOHDR_FLAGS_SUBDIVISION_SURFACE		0x80000

// flagged on load to indicate no animation events on this model
// might be a different thing on v54
#define STUDIOHDR_FLAGS_NO_ANIM_EVENTS			0x100000

// If flag is set then studiohdr_t.flVertAnimFixedPointScale contains the
// scale value for fixed point vert anim data, if not set then the
// scale value is the default of 1.0 / 4096.0.  Regardless use
// studiohdr_t::VertAnimFixedPointScale() to always retrieve the scale value
#define STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE	0x200000


// This flag indicates that the model has complex weights, which allows it to have 3< weights per bone.
#define STUDIOHDR_FLAGS_USES_EXTRA_BONE_WEIGHTS     0x4000 // don't really know what to name this one

#define STUDIOHDR_FLAGS_RESPAWN_UNK                 0x800000

// "colorindex is only shifted if 0x1000000 flag is set on the studiohdr" talking about colorindex in mstudiomodel struct
// If this flag is present the model has vertex color, and by extension (previously) a VVC (IDVC) file.
#define STUDIOHDR_FLAGS_USES_VERTEX_COLOR	        0x1000000

// If this flag is present the model has a secondary UV layer, and by extension (previously) a VVC (IDVC) file.
#define STUDIOHDR_FLAGS_USES_UV2			        0x2000000

string ReadHeaderFlags(int flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX:
            value += "STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX";
            break;
        case STUDIOHDR_FLAGS_USES_ENV_CUBEMAP:
            value += "STUDIOHDR_FLAGS_USES_ENV_CUBEMAP";
            break;
        case STUDIOHDR_FLAGS_FORCE_OPAQUE:
            value += "STUDIOHDR_FLAGS_FORCE_OPAQUE";
            break;
        case STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS:
            value += "STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS";
            break;
        case STUDIOHDR_FLAGS_STATIC_PROP:
            value += "STUDIOHDR_FLAGS_STATIC_PROP";
            break;
        case STUDIOHDR_FLAGS_USES_FB_TEXTURE:
            value += "STUDIOHDR_FLAGS_USES_FB_TEXTURE";
            break;
        case STUDIOHDR_FLAGS_HASSHADOWLOD:
            value += "STUDIOHDR_FLAGS_HASSHADOWLOD";
            break;
        case STUDIOHDR_FLAGS_USES_BUMPMAPPING:
            value += "STUDIOHDR_FLAGS_USES_BUMPMAPPING";
            break;
        case STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS:
            value += "STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS";
            break;
        case STUDIOHDR_FLAGS_OBSOLETE:
            value += "STUDIOHDR_FLAGS_OBSOLETE";
            break;
        case STUDIOHDR_FLAGS_UNUSED:
            value += "STUDIOHDR_FLAGS_UNUSED";
            break;
        case STUDIOHDR_FLAGS_NO_FORCED_FADE:
            value += "STUDIOHDR_FLAGS_NO_FORCED_FADE";
            break;
        case STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE:
            value += "STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE";
            break;
        case STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT:
            value += "STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT";
            break;
        case 0x4000:
            if(hdr.version == 54 || hdr.version == 1)
                value += "STUDIOHDR_FLAGS_USES_EXTRA_BONE_WEIGHTS";
            else
                value += "STUDIOHDR_FLAGS_FLEXES_CONVERTED";
            break;
        case STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE:
            value += "STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE";
            break;
        case STUDIOHDR_FLAGS_AMBIENT_BOOST:
            value += "STUDIOHDR_FLAGS_AMBIENT_BOOST";
            break;
        case STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS:
            value += "STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS";
            break;
        case STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS:
            value += "STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS";
            break;
        case STUDIOHDR_FLAGS_SUBDIVISION_SURFACE:
            value += "STUDIOHDR_FLAGS_SUBDIVISION_SURFACE";
            break;
        case STUDIOHDR_FLAGS_NO_ANIM_EVENTS:
            value += "STUDIOHDR_FLAGS_NO_ANIM_EVENTS";
            break;
        case STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE:
            value += "STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE";
            break;
        case STUDIOHDR_FLAGS_RESPAWN_UNK:
            value += "STUDIOHDR_FLAGS_RESPAWN_UNK";
            break;
        case STUDIOHDR_FLAGS_USES_VERTEX_COLOR:
            value += "STUDIOHDR_FLAGS_USES_VERTEX_COLOR";
            break;
        case STUDIOHDR_FLAGS_USES_UV2:
            value += "STUDIOHDR_FLAGS_USES_UV2";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

// public contents flags
// https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/public/bspflags.h
// https://github.com/NicolasDe/AlienSwarm/blob/master/src/public/bspflags.h

// source
// list is cut down from full source list
#define CONTENTS_EMPTY      0x0 // nonsolid
#define CONTENTS_SOLID      0x1 // solid
#define CONTENTS_GRATE      0x8 // grate
#define CONTENTS_MONSTER    0x2000000 // monster
#define CONTENTS_LADDER     0x20000000 // ladder

string ReadContents(int flags)
{
    string value = "";

    if(flags == CONTENTS_EMPTY)
        return "CONTENTS_EMPTY";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case CONTENTS_EMPTY:
            break;
        case CONTENTS_SOLID:
            value += "CONTENTS_SOLID";
            break;
        case CONTENTS_GRATE:
            value += "CONTENTS_GRATE";
            break;
        case CONTENTS_MONSTER:
            value += "CONTENTS_MONSTER";
            break;
        case CONTENTS_LADDER:
            value += "CONTENTS_LADDER";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

// r2
// no ladder
/*enum <int> contents_flags_r2 {
    CONTENTS_EMPTY = 0x0,
    CONTENTS_SOLID = 0x1,
    CONTENTS_WINDOW = 0x2,
    CONTENTS_AUX = 0x4,
    CONTENTS_GRATE = 0x8,
    CONTENTS_SLIME = 0x10,
    CONTENTS_WATER = 0x20,
    CONTENTS_WINDOW_NOCOLLIDE = 0x40,
    CONTENTS_OPAQUE = 0x80,
    CONTENTS_TESTFOGVOLUME = 0x100,
    CONTENTS_PHYSICSCLIP = 0x200,
    CONTENTS_BLOCKLIGHT = 0x400,
    CONTENTS_NOGRAPPLE = 0x800,
    CONTENTS_UNUSED_03 = 0x1000,
    CONTENTS_IGNORE_NODRAW_OPAQUE = 0x2000,
    CONTENTS_MOVEABLE = 0x4000,
    CONTENTS_TEST_SOLID_BODY_SHOT = 0x8000,
    CONTENTS_PLAYERCLIP = 0x10000,
    CONTENTS_MONSTERCLIP = 0x20000,
    CONTENTS_OPERATOR_FLOOR = 0x40000,
    CONTENTS_BLOCKLOS = 0x80000,
    CONTENTS_NOCLIMB = 0x100000,
    CONTENTS_TITANCLIP = 0x200000,
    CONTENTS_BULLETCLIP = 0x400000,
    CONTENTS_OPERATORCLIP = 0x800000,
    CONTENTS_MONSTER = 0x2000000,
    CONTENTS_DEBRIS = 0x4000000,
    CONTENTS_DETAIL = 0x8000000,
    CONTENTS_TRANSLUCENT = 0x10000000,
    CONTENTS_HITBOX = 0x40000000,
};

// r5
// ladder replaced by ping
enum <int> contents_flags_r5 {
    CONTENTS_EMPTY = 0x0,
    CONTENTS_SOLID = 0x1,
    CONTENTS_WINDOW = 0x2,
    CONTENTS_AUX = 0x4,
    CONTENTS_GRATE = 0x8,
    CONTENTS_SLIME = 0x10,
    CONTENTS_WATER = 0x20,
    CONTENTS_WINDOW_NOCOLLIDE = 0x40,
    CONTENTS_OPAQUE = 0x80,
    CONTENTS_TESTFOGVOLUME = 0x100,
    CONTENTS_PHYSICSCLIP = 0x200,
    CONTENTS_NOGRAPPLE = 0x400,
    CONTENTS_IGNORE_NODRAW_OPAQUE = 0x2000,
    CONTENTS_MOVEABLE = 0x4000,
    CONTENTS_TEST_SOLID_BODY_SHOT = 0x8000,
    CONTENTS_PLAYERCLIP = 0x10000,
    CONTENTS_MONSTERCLIP = 0x20000,
    CONTENTS_OPERATOR_FLOOR = 0x40000,
    CONTENTS_BLOCKLOS = 0x80000,
    CONTENTS_NOCLIMB = 0x100000,
    CONTENTS_TITANCLIP = 0x200000,
    CONTENTS_BULLETCLIP = 0x400000,
    CONTENTS_OPERATORCLIP = 0x800000,
    CONTENTS_NOAIRDROP = 0x1000000,
    CONTENTS_MONSTER = 0x2000000,
    CONTENTS_DEBRIS = 0x4000000,
    CONTENTS_DETAIL = 0x8000000,
    CONTENTS_TRANSLUCENT = 0x10000000,
    CONTENTS_BLOCK_PING = 0x20000000,
    CONTENTS_HITBOX = 0x40000000,
}*/

// header structs
struct studiohdr_t_v47
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

	Vector illumposition;	// illumination center
	
	Vector hull_min;		// ideal movement hull size
	Vector hull_max;			

	Vector view_bbmin;		// clipping bounding box
	Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // raw textures
	int numtextures;
	int textureindex;
 
    /// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int numflexdesc;
	int flexdescindex;
 
    int numflexcontrollers;
	int flexcontrollerindex;
 
    int numflexrules;
	int flexruleindex;
 
    int numikchains;
	int ikchainindex;
	
    int nummouths;
	int mouthindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
 
    float mass;
	int contents <read=ReadContents(this)>;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
    uint32 virtualModel;
 
    int szanimblocknameindex <read=ReadString(this)>;	
	int numanimblocks;
	int animblockindex;
	uint32 animblockModel;

	int bonetablebynameindex;

    // used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	uint32 pVertexBase;
	uint32 pIndexBase;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;
    
    int unused1[7];
};

// main headers
struct studiohdr_t_v48
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

	Vector illumposition;	// illumination center
	
	Vector hull_min;		// ideal movement hull size
	Vector hull_max;			

	Vector view_bbmin;		// clipping bounding box
	Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // raw textures
	int numtextures;
	int textureindex;
 
    /// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int numflexdesc;
	int flexdescindex;
 
    int numflexcontrollers;
	int flexcontrollerindex;
 
    int numflexrules;
	int flexruleindex;
 
    int numikchains;
	int ikchainindex;
	
    int nummouths;
	int mouthindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
 
    float mass;
	int contents <read=ReadContents(this)>;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
    uint32 virtualModel;
 
    int szanimblocknameindex <read=ReadString(this)>;	
	int numanimblocks;
	int animblockindex;
	uint32 animblockModel;

	int bonetablebynameindex;
    
    // used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	uint32 pVertexBase;
	uint32 pIndexBase;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	int unused4; // zero out if version < 47

	int numflexcontrollerui;
	int flexcontrolleruiindex;

    float flVertAnimFixedPointScale;

    int unused3;
    
	int studiohdr2index;
	
    // NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int unused2;
};

struct studiohdr_t_v49
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

	Vector illumposition;	// illumination center
	
	Vector hull_min;		// ideal movement hull size
	Vector hull_max;			

	Vector view_bbmin;		// clipping bounding box
	Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // raw textures
	int numtextures;
	int textureindex;
 
    /// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int numflexdesc;
	int flexdescindex;
 
    int numflexcontrollers;
	int flexcontrollerindex;
 
    int numflexrules;
	int flexruleindex;
 
    int numikchains;
	int ikchainindex;
	
    int nummouths;
	int mouthindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
 
    float mass;
	int contents <read=ReadContents(this)>;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
    uint32 virtualModel;
 
    int szanimblocknameindex <read=ReadString(this)>;	
	int numanimblocks;
	int animblockindex;
	uint32 animblockModel;

	int bonetablebynameindex;
    
    // used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	uint32 pVertexBase;
	uint32 pIndexBase;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	int unused4; // zero out if version < 47

	int numflexcontrollerui;
	int flexcontrolleruiindex;

    float flVertAnimFixedPointScale;
    int surfacepropLookup; // this index must be cached by the loader, not saved in the file
    
	int studiohdr2index;
	
    // NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int unused2;
};

struct studiohdr_t_v52
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

	Vector illumposition;	// illumination center
	
	Vector hull_min;		// ideal movement hull size
	Vector hull_max;			

	Vector view_bbmin;		// clipping bounding box
	Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    // highest observed: 250
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;
 
    // raw textures
	int numtextures;
	int textureindex;
 
    /// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int deprecated_numflexdesc;
	int deprecated_flexdescindex;
 
    int deprecated_numflexcontrollers;
	int deprecated_flexcontrollerindex;
 
    int deprecated_numflexrules;
	int deprecated_flexruleindex;
 
    int numikchains;
	int ikchainindex;
	
    int deprecated_nummouths;
	int deprecated_mouthindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
 
    float mass;
	int contents <read=ReadContents(this)>;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
	// implementation specific back pointer to virtual data
	int /* mutable void* */ virtualModel;

	// for demand loaded animation blocks
	int szanimblocknameindex <read=ReadString(this)>;

	int numanimblocks;
	int animblockindex;

	int /* mutable void* */ animblockModel;

	int bonetablebynameindex;

	// used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	int /* void* */ pVertexBase;
	int /* void* */ pIndexBase;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadeDistance;

	int deprecated_numflexcontrollerui;
	int deprecated_flexcontrolleruiindex;

    float flVertAnimFixedPointScale;
    int surfacepropLookup;	// this index must be cached by the loader, not saved in the file
    
	// NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int studiohdr2index;
	
	int sourceFilenameOffset; // in v52 not every model has these strings, only four bytes when not present.
};

struct studiohdr_t_v53
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex <read=ReadString(this)>; // This has been moved from studiohdr2 to the front of the main header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

	Vector illumposition;	// illumination center
	
	Vector hull_min;		// ideal movement hull size
	Vector hull_max;			

	Vector view_bbmin;		// clipping bounding box
	Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    // highest observed: 250
    // max is definitely 256 because 8bit uint limit
    int numbones; // bones
	int boneindex;
 
    int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
    int numhitboxsets;
	int hitboxsetindex;
 
    int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed? set on load
	int eventsindexed;
 
    // mstudiotexture_t
    // short rpak path
	// raw textures
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
    // replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
    int numlocalattachments;
	int localattachmentindex;
 
    int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
    int deprecated_numflexdesc;
	int deprecated_flexdescindex;
 
    int deprecated_numflexcontrollers;
	int deprecated_flexcontrollerindex;
 
    int deprecated_numflexrules;
	int deprecated_flexruleindex;
 
    int numikchains;
	int ikchainindex;

    int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
	int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
	int keyvaluesize;
 
    int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
    float mass;
	int contents <read=ReadContents(this)>;
 
    // external animations, models, etc.
	int numincludemodels;
	int includemodelindex;
    
    int virtualModel; // should be void

    // animblock is either completely cut, this is because they no longer use .ani files.

	int bonetablebynameindex;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadeDistance; // set to -1 to never fade. set above 0 if you want it to fade out, distance is in feet.
                        // player/titan models seem to inherit this value from the first model loaded in menus.
                        // works oddly on entities, probably only meant for static props

	int deprecated_numflexcontrollerui;
	int deprecated_flexcontrolleruiindex;
    
    float flVertAnimFixedPointScale;
    int surfacepropLookup; // this index must be cached by the loader, not saved in the file

    // this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
    // doesn't actually need to be written pretty sure, only four bytes when not present.
    // this is not completely true as some models simply have nothing, such as animation models.
	int sourceFilenameOffset;

    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;
	
	int linearboneindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;
    
    // for static props (and maybe others)
    // Precomputed Per-Triangle AABB data
    int m_nPerTriAABBIndex;
    int m_nPerTriAABBNodeCount;
    int m_nPerTriAABBLeafCount;
    int m_nPerTriAABBVertCount;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(this)>;

    // ANIs are no longer used and this is reflected in many structs
    // Start of interal file data
    int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize; // VTX
    int vvdsize; // VVD / IDSV
    int vvcsize; // VVC / IDCV 
    int vphysize; // VPHY / IVPS

    // this data block is related to the vphy, if it's not present the data will not be written
    // definitely related to phy, apex phy has this merged into it
    int unkindex; // section between vphy and vtx.?
    int numunk; // only seems to be used when phy has one solid

    // mostly seen on '_animated' suffixed models
	// manually declared bone followers are no longer stored in kvs under 'bone_followers', they are now stored in an array of ints with the bone index.
	int numbonefollowers; // numBoneFollowers
	int bonefollowerindex;

    int unused1[60];

};

// sub header
// v48/49 are the same
struct studiohdr2_t
{
	// NOTE: For forward compat, make sure any methods in this struct
	// are also available in studiohdr_t so no leaf code ever directly references
	// a studiohdr2_t structure
	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection; // default to cos(30) if not set
	
	int linearboneindex;

	int sznameindex <read=ReadString(startof(mdlSubHeader) + this)>;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;

	int reserved[56];
};

struct studiohdr2_t_v52
{
    int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection; // default to cos(30) if not set
	
	int linearboneindex;

	int sznameindex <read=ReadString(startof(mdlSubHeader) + this)>;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;
    
    // for static props (and maybe others)
    // Precomputed Per-Triangle AABB data
    int m_nPerTriAABBIndex;
    int m_nPerTriAABBNodeCount;
    int m_nPerTriAABBLeafCount;
    int m_nPerTriAABBVertCount;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(startof(mdlSubHeader) + mdlSubHeader.unkstringindex)>;

	int reserved[39];
};


//=============
// Bone Structs


// bones
#define STUDIO_PROC_AXISINTERP	1
#define STUDIO_PROC_QUATINTERP	2
#define STUDIO_PROC_AIMATBONE	3
#define STUDIO_PROC_AIMATATTACH 4
#define STUDIO_PROC_JIGGLE		5
#define STUDIO_PROC_TWIST_MASTER 6
#define STUDIO_PROC_TWIST_SLAVE 7	// Multiple twist bones are computed at once for the same parent/child combo so TWIST_NULL do nothing

string ReadProcFlags(uint flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    switch(flags)
    {
    case 0:
        break;
    case STUDIO_PROC_AXISINTERP:
        value += "STUDIO_PROC_AXISINTERP";
        break;
    case STUDIO_PROC_QUATINTERP:
        value += "STUDIO_PROC_QUATINTERP";
        break;
    case STUDIO_PROC_AIMATBONE:
        value += "STUDIO_PROC_AIMATBONE";
        break;
    case STUDIO_PROC_AIMATATTACH:
        value += "STUDIO_PROC_AIMATATTACH";
        break;
    case STUDIO_PROC_JIGGLE:
        value += "STUDIO_PROC_JIGGLE";
        break;
    case STUDIO_PROC_TWIST_MASTER:
        value += "STUDIO_PROC_TWIST_MASTER";
        break;
    case STUDIO_PROC_TWIST_SLAVE:
        value += "STUDIO_PROC_TWIST_SLAVE";
        break;
    default:
        value += Str("UNK_%x", flag);
        break;
    }

    return value;
}

// for poseToBone:

// postion is where the origin is relative to this bone, so any transforms are a. inverted, and b. additive of any parents.
// or just the distance/directions/transformation needed to travel to place it at the origin

// the quaternion's rotation matrix is mapped assuming the provide image is the layout:
// https://wikimedia.org/api/rest_v1/media/math/render/svg/2036e2c76a8e1c3638fbec4e148d0a9034d1a453

//   c0     c1     c2        c3
// a m00; d m01; g m02; posX m03; // r0
// b m10; e m11; h m12; PosY m13; // r1
// c m20; f m21; i m22; posZ m23; // r2

// bone flags
#define BONE_CALCULATE_MASK			0x1F
#define BONE_PHYSICALLY_SIMULATED	0x01	// bone is physically simulated when physics are active
#define BONE_PHYSICS_PROCEDURAL		0x02	// procedural when physics is active
#define BONE_ALWAYS_PROCEDURAL		0x04	// bone is always procedurally animated
#define BONE_SCREEN_ALIGN_SPHERE	0x08	// bone aligns to the screen, not constrained in motion.
#define BONE_SCREEN_ALIGN_CYLINDER	0x10	// bone aligns to the screen, constrained by it's own axis.

#define BONE_WORLD_ALIGN 0x20 // bone is rigidly aligned to the world (but can still translate)(added in CSGO)

#define BONE_USED_BY_IKCHAIN 0x20 // bone is influenced by IK chains, added in V52 (Titanfall 1)

#define BONE_USED_MASK				0x0007FF00
#define BONE_USED_BY_ANYTHING		0x0007FF00
#define BONE_USED_BY_HITBOX			0x00000100	// bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT		0x00000200	// bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK	0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0	0x00000400	// bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1	0x00000800	
#define BONE_USED_BY_VERTEX_LOD2	0x00001000  
#define BONE_USED_BY_VERTEX_LOD3	0x00002000
#define BONE_USED_BY_VERTEX_LOD4	0x00004000
#define BONE_USED_BY_VERTEX_LOD5	0x00008000
#define BONE_USED_BY_VERTEX_LOD6	0x00010000
#define BONE_USED_BY_VERTEX_LOD7	0x00020000
#define BONE_USED_BY_BONE_MERGE		0x00040000	// bone is available for bone merge to occur against it

#define BONE_FLAG_UNK_53            0x00080000 // where?

//#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
//#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )

#define BONE_TYPE_MASK				0x00F00000
#define BONE_FIXED_ALIGNMENT		0x00100000	// bone can't spin 360 degrees, all interpolation is normalized around a fixed orientation

#define BONE_HAS_SAVEFRAME_POS		0x00200000	// Vector48
// v48 -> v49 : BONE_HAS_SAVEFRAME_ROT -> BONE_HAS_SAVEFRAME_ROT64
#define BONE_HAS_SAVEFRAME_ROT64	0x00400000	// Quaternion64
#define BONE_HAS_SAVEFRAME_ROT32	0x00800000	// Quaternion32

#define BONE_FLAG_UNK_52            0x01000000 // where?

string ReadBoneFlags(uint flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case BONE_CALCULATE_MASK:
            value += "BONE_CALCULATE_MASK";
            break;
        case BONE_PHYSICALLY_SIMULATED:
            value += "BONE_PHYSICALLY_SIMULATED";
            break;
        case BONE_PHYSICS_PROCEDURAL:
            value += "BONE_PHYSICS_PROCEDURAL";
            break;
        case BONE_ALWAYS_PROCEDURAL:
            value += "BONE_ALWAYS_PROCEDURAL";
            break;
        case BONE_SCREEN_ALIGN_SPHERE:
            value += "BONE_SCREEN_ALIGN_SPHERE";
            break;
        case BONE_SCREEN_ALIGN_CYLINDER:
            value += "BONE_SCREEN_ALIGN_CYLINDER";
            break;
        case BONE_USED_BY_IKCHAIN:
            value += "BONE_USED_BY_IKCHAIN";
            break;
        case BONE_USED_MASK:
            value += "BONE_USED_MASK";
            break;
        case BONE_USED_BY_ANYTHING:
            value += "BONE_USED_BY_ANYTHING";
            break;
        case BONE_USED_BY_HITBOX:
            value += "BONE_USED_BY_HITBOX";
            break;
        case BONE_USED_BY_ATTACHMENT:
            value += "BONE_USED_BY_ATTACHMENT";
            break;
        case BONE_USED_BY_VERTEX_MASK:
            value += "BONE_USED_BY_VERTEX_MASK";
            break;
        case BONE_USED_BY_VERTEX_LOD0:
            value += "BONE_USED_BY_VERTEX_LOD0";
            break;
        case BONE_USED_BY_VERTEX_LOD1:
            value += "BONE_USED_BY_VERTEX_LOD1";
            break;
        case BONE_USED_BY_VERTEX_LOD2:
            value += "BONE_USED_BY_VERTEX_LOD2";
            break;
        case BONE_USED_BY_VERTEX_LOD3:
            value += "BONE_USED_BY_VERTEX_LOD3";
            break;
        case BONE_USED_BY_VERTEX_LOD4:
            value += "BONE_USED_BY_VERTEX_LOD4";
            break;
        case BONE_USED_BY_VERTEX_LOD5:
            value += "BONE_USED_BY_VERTEX_LOD5";
            break;
        case BONE_USED_BY_VERTEX_LOD4:
            value += "BONE_USED_BY_VERTEX_LOD6";
            break;
        case BONE_USED_BY_VERTEX_LOD5:
            value += "BONE_USED_BY_VERTEX_LOD7";
            break;
        case BONE_USED_BY_BONE_MERGE:
            value += "BONE_USED_BY_BONE_MERGE";
            break;
        case BONE_FLAG_UNK_53:
            value += "BONE_FLAG_UNK_53";
            break;
        case BONE_TYPE_MASK:
            value += "BONE_TYPE_MASK";
            break;
        case BONE_FIXED_ALIGNMENT:
            value += "BONE_FIXED_ALIGNMENT";
            break;
        case BONE_HAS_SAVEFRAME_POS:
            value += "BONE_HAS_SAVEFRAME_POS";
            break;
        case BONE_HAS_SAVEFRAME_ROT64:
            value += "BONE_HAS_SAVEFRAME_ROT64";
            break;
        case BONE_HAS_SAVEFRAME_ROT32:
            value += "BONE_HAS_SAVEFRAME_ROT32";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

// works good enough but might not be good for edge cases with unparented bones.
int ReadParentBone(int bone)
{
    int realbone = 0;

    if(bone < 0)
        realbone = 0;
    else
        realbone = bone;

    return realbone;
}

// bone structs
struct mstudiobone_t_v47
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector pos; // base bone position
	Quaternion quat;
	RadianEuler rot; // base bone rotation

	// compression scale
	Vector posscale; // scale muliplier for bone position in animations
	Vector rotscale; // scale muliplier for bone rotation in animations

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags <read=ReadBoneFlags(this)>;
	int proctype <read=ReadProcFlags(this)>;
    int procindex; // procedural rule offset
	int physicsbone; // index into physically simulated bone
	
    int surfacepropidx <read=ReadString(startof(this) + this - 176)>; // index into string tablefor property name

	int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags

	int unused[8]; // remove as appropriate
};

struct mstudiobone_t_v49
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector pos; // base bone position
	Quaternion quat;
	RadianEuler rot; // base bone rotation

	// compression scale
	Vector posscale; // scale muliplier for bone position in animations
	Vector rotscale; // scale muliplier for bone rotation in animations

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags <read=ReadBoneFlags(this)>;
	int proctype <read=ReadProcFlags(this)>;
    int procindex; // procedural rule offset
	int physicsbone; // index into physically simulated bone

    int surfacepropidx <read=ReadString(startof(this) + this - 176)>; // index into string tablefor property name
	
	int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags
	
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
	
	int unused[7]; // remove as appropriate
};

struct mstudiobone_t_v52
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector pos; // base bone position
	Quaternion quat;
	RadianEuler rot; // base bone rotation
	
	// compression scale
	Vector posscale; // scale muliplier for bone position in animations
	Vector rotscale; // scale muliplier for bone rotation in animations

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags <read=ReadBoneFlags(this)>;
	int proctype <read=ReadProcFlags(this)>;
    int procindex; // procedural rule offset
	int physicsbone; // index into physically simulated bone

    int surfacepropidx <read=ReadString(startof(this) + this - 176)>; // index into string tablefor property name
	
	int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags
	
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
	
    // bone scale(?)
	Vector scale;	
	Vector scalescale;
	
	int unused[1]; // remove as appropriate
};

struct mstudiobone_t_v53
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector pos; // base bone position
	Quaternion quat;
	RadianEuler rot; // base bone rotation
	Vector scale; // bone scale(?)
	
	// compression scale
	Vector posscale; // scale muliplier for bone position in animations. depreciated in v53, as the posscale is stored in anim bone headers
	Vector rotscale; // scale muliplier for bone rotation in animations
	Vector scalescale; // scale muliplier for scale

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

    int flags <read=ReadBoneFlags(this)>;
	int proctype <read=ReadProcFlags(this)>;
    int procindex; // procedural rule offset
	int physicsbone; // index into physically simulated bone

    int surfacepropidx <read=ReadString(startof(this) + this - 200)>; // index into string tablefor property name
	
	int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags
	
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
	
    // unknown phy related section
	short unkindex; // index into this section
    short unkcount; // number of sections for this bone?? see: models\s2s\s2s_malta_gun_animated.mdl
	
	int unused[7]; // remove as appropriate
};

#define JIGGLE_IS_FLEXIBLE				0x01
#define JIGGLE_IS_RIGID					0x02
#define JIGGLE_HAS_YAW_CONSTRAINT		0x04
#define JIGGLE_HAS_PITCH_CONSTRAINT		0x08
#define JIGGLE_HAS_ANGLE_CONSTRAINT		0x10
#define JIGGLE_HAS_LENGTH_CONSTRAINT	0x20
#define JIGGLE_HAS_BASE_SPRING			0x40

string ReadJiggleFlags(int flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case JIGGLE_IS_FLEXIBLE:
            value += "JIGGLE_IS_FLEXIBLE";
            break;
        case JIGGLE_IS_RIGID:
            value += "JIGGLE_IS_RIGID";
            break;
        case JIGGLE_HAS_YAW_CONSTRAINT:
            value += "JIGGLE_HAS_YAW_CONSTRAINT";
            break;
        case JIGGLE_HAS_PITCH_CONSTRAINT:
            value += "JIGGLE_HAS_PITCH_CONSTRAINT";
            break;
        case JIGGLE_HAS_ANGLE_CONSTRAINT:
            value += "JIGGLE_HAS_ANGLE_CONSTRAINT";
            break;
        case JIGGLE_HAS_LENGTH_CONSTRAINT:
            value += "JIGGLE_HAS_LENGTH_CONSTRAINT";
            break;
        case JIGGLE_HAS_BASE_SPRING:
            value += "JIGGLE_HAS_BASE_SPRING";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

// jigglebone
struct mstudiojigglebone_t
{
	int flags <read=ReadJiggleFlags(this)>;

	// general params
	float length; // how far from bone base, along bone, is tip
	float tipMass;

	// flexible params
	float yawStiffness;
	float yawDamping;	
	float pitchStiffness;
	float pitchDamping;	
	float alongStiffness;
	float alongDamping;	

	// angle constraint
	float angleLimit; // maximum deflection of tip in radians
	
	// yaw constraint
	float minYaw; // in radians
	float maxYaw; // in radians
	float yawFriction;
	float yawBounce;
	
	// pitch constraint
	float minPitch; // in radians
	float maxPitch; // in radians
	float pitchFriction;
	float pitchBounce;

	// base spring
	float baseMass;
	float baseStiffness;
	float baseDamping;	
	float baseMinLeft;
	float baseMaxLeft;
	float baseLeftFriction;
	float baseMinUp;
	float baseMaxUp;
	float baseUpFriction;
	float baseMinForward;
	float baseMaxForward;
	float baseForwardFriction;
};

// flexdriver
struct mstudioboneflexdriver_t
{
	int m_nBoneIndex;			// Bone to drive flex controller
	int m_nControlCount;		// Number of flex controllers being driven
	int m_nControlIndex;		// Index into data where controllers are (relative to this)

	int unused[3];
};

// attachments
struct mstudioattachment_t
{
	int sznameindex <read=ReadString(startof(this) + this)>;
	int flags;

	int localbone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // parent bone

	matrix3x4_t localmatrix; // attachment point

    //    c0         c1         c2       c3
    //float m00 float m01 float m02 posX m03 // r0
    //float m10 float m11 float m12 posY m13 // r1
    //float m20 float m21 float m22 PosZ m23 // r2

	int	unused[8];
};

// ikchain
struct mstudioikchain_t
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int linktype;
	int numlinks;
	int linkindex;
};

struct mstudioikchain_t_v53
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int linktype;
	int numlinks;
	int linkindex;
    
    float unk; // no clue what this does tbh, tweaking it does nothing
               // default value: 0.707f
               // this value is similar to default source engine ikchain values
    
    int unused[3]; // these get cut in apex so I can't imagine this is used
};

// ikinfo
struct mstudioiklink_t
{
	int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
	Vector	kneeDir; // ideal bending direction (per link, if applicable), unknown in v53
	Vector	unused0; // unused in v49
};

// iklock
// this struct doesn't change for V52
struct mstudioiklock_t
{
	int chain;
	float flPosWeight;
	float flLocalQWeight;
	int flags;

	int unused[4];
};

// mouth
struct mstudiomouth_t
{
	int					bone;
	Vector				forward;
	int					flexdesc;
};


// pose parameter desc
struct mstudioposeparamdesc_t
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int flags; // ????
	float start; // starting value
	float end; // ending value
	float loop;	// looping range, 0 for no looping, 360 for rotations, etc.
};

// flexes
struct mstudioflexdesc_t
{
	int szFACSindex <read=ReadString(startof(this) + this)>;
};



struct mstudioflexcontroller_t
{
	int sztypeindex <read=ReadString(startof(this) + this)>;
	int sznameindex <read=ReadString(startof(this) + this - 4)>;
	int localToGlobal;	// remapped at load time to master list
	float min;
	float max;
};

struct mstudioflexrule_t
{
	int flex;
	int numops;
	int opindex;
};

struct mstudioflexop_t
{
	int op;
	union 
	{
		int index;
		float value;
	} d;
};

struct mstudioflexcontrollerui_t
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	// These are used like a union to save space
	// Here are the possible configurations for a UI controller
	//
	// SIMPLE NON-STEREO:	0: control	1: unused	2: unused
	// STEREO:				0: left		1: right	2: unused
	// NWAY NON-STEREO:		0: control	1: unused	2: value
	// NWAY STEREO:			0: left		1: right	2: value

	int szindex0;
	int szindex1;
	int szindex2;

	unsigned char remaptype;	// See the FlexControllerRemapType_t enum
	bool stereo;		// Is this a stereo control?
	byte unused[2];
};

// source bone transform
struct mstudiosrcbonetransform_t
{
	int sznameindex;

	matrix3x4_t	pretransform;	
	matrix3x4_t	posttransform;	
};

// linear bone
struct mstudiolinearbone_t	
{
	int numbones;

	int flagsindex;

	int	parentindex;
	
	int	posindex;
	
	int quatindex;
	
	int rotindex;
	
	int posetoboneindex;
	
	int	posscaleindex;
	
	int	rotscaleindex;
	
	int	qalignmentindex;
	
	int unused[6];
};


//===============
// Hitbox Structs


// hboxset
struct mstudiohitboxset_t
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int numhitboxes;
	int hitboxindex;
};

enum <int> hboxgroup
{
    Generic = 0,
    Head = 1,
    Chest = 2,
    Stomach = 3,
    Left_Arm = 4,
    Right_Arm = 5,
    Left_Leg = 6,
    Right_Leg = 7,
    Neck = 8
};

// hit box boxes
struct mstudiobbox_t
{
	int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
	hboxgroup group; // intersection group

	Vector bbmin; // bounding box
	Vector bbmax;	

	int szhitboxnameindex <read=ReadString(startof(this) + this - 32)>; // offset to the name of the hitbox.
	
	int unused[8];
};

struct mstudiobbox_t_v53
{
	int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
	hboxgroup group; // intersection group

	Vector bbmin; // bounding box
	Vector bbmax;	

	int szhitboxnameindex <read=ReadString(startof(this) + this - 32)>; // offset to the name of the hitbox.
    
    int critoverride; // overrides the group to be a crit, 0 or 1. might be group override since group 1 is head.
    int keyvalueindex <read=ReadString(startof(this) + this - 40)>; // indexes into a kv group if used, mostly for titans.

	int unused[6];
};


//==================
// Animation Structs


// sequence and autolayer flags
#define STUDIO_LOOPING	0x0001		// ending frame should be the same as the starting frame
#define STUDIO_SNAP		0x0002		// do not interpolate between previous animation and this one
#define STUDIO_DELTA	0x0004		// this sequence "adds" to the base sequences, not slerp blends
#define STUDIO_AUTOPLAY	0x0008		// temporary flag that forces the sequence to always play
#define STUDIO_POST		0x0010		// 
#define STUDIO_ALLZEROS	0x0020		// this animation/sequence has no real animation data
#define STUDIO_FRAMEANIM 0x0040		// animation is encoded as by frame x bone instead of RLE bone x frame
#define STUDIO_CYCLEPOSE 0x0080		// cycle index is taken from a pose parameter index
#define STUDIO_REALTIME	0x0100		// cycle index is taken from a real-time clock, not the animations cycle index
#define STUDIO_LOCAL	0x0200		// sequence has a local context sequence
#define STUDIO_HIDDEN	0x0400		// don't show in default selection views
#define STUDIO_OVERRIDE	0x0800		// a forward declared sequence (empty)
#define STUDIO_ACTIVITY	0x1000		// Has been updated at runtime to activity index
#define STUDIO_EVENT	0x2000		// Has been updated at runtime to event index on server
#define STUDIO_WORLD	0x4000		// sequence blends in worldspace
#define STUDIO_NOFORCELOOP 0x8000	// do not force the animation loop
#define STUDIO_EVENT_CLIENT 0x10000	// Has been updated at runtime to event index on client

// new in respawn models
#define STUDIO_ANIM_UNK3        0x0040  // used on something that is clearly not a frame anim in v54
                                    // animseq/humans/class/heavy/mp_pilot_heavy_core/mp_pt_crypto_base_execution_heavy_victim.rseq
#define STUDIO_ANIM_UNK		    0x20000 // actually first in v52, from where??
                                        // this may actually be something different in apex, as all anims need this or else it does not read values
#define STUDIO_FRAMEMOVEMENT    0x40000 // framemovements are only read if this flag is present
#define STUDIO_ANIM_UNK2	    0x80000 // cherry blossom v53, levi in v54

string ReadAnimDescFlags(int flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x1:
            value += "STUDIO_LOOPING";
            break;
        case 0x2:
            value += "STUDIO_SNAP";
            break;
        case 0x4:
            value += "STUDIO_DELTA";
            break;
        case 0x8:
            value += "STUDIO_AUTOPLAY";
            break;
        case 0x10:
            value += "STUDIO_POST";
            break;
        case 0x20:
            value += "STUDIO_ALLZEROS";
            break;
        case 0x40:
            value += "STUDIO_FRAMEANIM";
            break;
        case 0x80:
            value += "STUDIO_CYCLEPOSE";
            break;
        case 0x100:
            value += "STUDIO_REALTIME";
            break;
        case 0x200:
            value += "STUDIO_LOCAL";
            break;
        case 0x400:
            value += "STUDIO_HIDDEN";
            break;
        case 0x800:
            value += "STUDIO_OVERRIDE";
            break;
        case 0x1000:
            value += "STUDIO_ACTIVITY";
            break;
        case 0x2000:
            value += "STUDIO_EVENT";
            break;
        case 0x4000:
            value += "STUDIO_WORLD";
            break;
        case 0x8000:
            value += "STUDIO_NOFORCELOOP";
            break;
        case 0x10000:
            value += "STUDIO_EVENT_CLIENT";
            break;
        case 0x20000:
            value += "STUDIO_ANIM_UNK";
            break;
        case STUDIO_FRAMEMOVEMENT:
            value += "STUDIO_FRAMEMOVEMENT";
            break;
        case STUDIO_ANIM_UNK2:
            value += "STUDIO_ANIM_UNK2";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

// animdesc, what.
struct mstudioanimdesc_t_v48
{
	int baseptr;

	int sznameindex <read=ReadString(startof(this) + this - 4)>;

	float fps; // frames per second	
	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int	nummovements;
	int movementindex;

	int unused1[6]; // remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl
	int animblockikruleindex; // non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;

	float zeroframestalltime; // saved during read stalls

};

struct mstudioanimdesc_t_v49
{
	int baseptr;

	int sznameindex <read=ReadString(startof(this) + this - 4)>;

	float fps; // frames per second	
	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int	nummovements;
	int movementindex;

    int ikrulezeroframeindex;

	int unused1[5]; // remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl
	int animblockikruleindex; // non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;

	float zeroframestalltime; // saved during read stalls
};

struct mstudioanimdesc_t_v52
{
	int baseptr;

	int sznameindex <read=ReadString(startof(this) + this - 4)>;

	float fps; // frames per second	
	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int	nummovements;
	int movementindex;

    int ikrulezeroframeindex;

    int framemovementindex; // new in v52

	int unused1[4]; // remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl
	int animblockikruleindex; // non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;

	float zeroframestalltime; // saved during read stalls
};

//typedef int offset <read=Str("%d  =>  %d", this, this - parentof(this).baseptr)>;
struct mstudioanimdesc_t_v53
{
	int baseptr;

	int sznameindex <read=ReadString(startof(this) + this - 4)>;

	float fps; // frames per second	
	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int nummovements;
	int movementindex;

	int framemovementindex; // new in v52

	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl

	int numlocalhierarchy;
	int localhierarchyindex;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

    int unused[8];
};

struct mstudioanimsections_t
{
	int animblock; // index of animblock
	int animindex;
};

// used for piecewise loading of animation data
struct mstudioanimblock_t
{
	int datastart;
	int dataend;
};

struct mstudioanimsections_t_v53
{
	int animindex;
};

// v48/49/52 flags
// v52 might've added flags for scale
#define STUDIO_ANIM_RAWPOS	0x01 // Vector48
#define STUDIO_ANIM_RAWROT	0x02 // Quaternion48
#define STUDIO_ANIM_ANIMPOS	0x04 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMROT	0x08 // mstudioanim_valueptr_t
#define STUDIO_ANIM_DELTA	0x10
#define STUDIO_ANIM_RAWROT2	0x20 // Quaternion64
#define STUDIO_ANIM_RAWSCALE	0x40 // Vector48
#define STUDIO_ANIM_ANIMSCALE	0x80 // mstudioanim_valueptr_t 

// v53 flags
#define STUDIO_ANIM_DELTA_53    0x01 // this appears to be delta until proven otherwise
// These work as toggles, flag enabled = raw data, flag disabled = pointers
#define STUDIO_ANIM_RAWPOS_53	0x02 // Vector48
#define STUDIO_ANIM_RAWROT_53	0x04 // Quaternion48
// drone_frag.mdl for scale track usage
#define STUDIO_ANIM_RAWSCALE_53	0x08 // Vector48
#define STUDIO_ANIM_NOTROT_53   0x10

string ReadAnimFlags(unsigned char flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    unsigned char flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x1:
            value += "STUDIO_ANIM_RAWPOS";
            break;
        case 0x2:
            value += "STUDIO_ANIM_RAWROT";
            break;
        case 0x4:
            value += "STUDIO_ANIM_ANIMPOS";
            break;
        case 0x8:
            value += "STUDIO_ANIM_ANIMROT";
            break;
        case 0x10:
            value += "STUDIO_ANIM_DELTA";
            break;
        case 0x20:
            value += "STUDIO_ANIM_RAWROT2";
            break;
        case STUDIO_ANIM_RAWSCALE:
            value += "STUDIO_ANIM_RAWSCALE";
            break;
        case STUDIO_ANIM_ANIMSCALE:
            value += "STUDIO_ANIM_ANIMSCALE";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

string ReadAnimFlagsV53(byte flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    byte flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x1:
            value += "STUDIO_ANIM_DELTA_53";
            break;
        case 0x2:
            value += "STUDIO_ANIM_RAWPOS_53";
            break;
        case 0x4:
            value += "STUDIO_ANIM_RAWROT_53";
            break;
        case 0x8:
            value += "STUDIO_ANIM_RAWSCALE_53";
            break;
        case 0x10:
            value += "STUDIO_ANIM_NOTROT_53";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

struct mstudioanim_valueptr_t
{
    short offset[3];
};

/*
void ExtractAnimValue( int frame, mstudioanimvalue_t *panimvalue, float scale, float &v1 )
{
	if ( !panimvalue )
	{
		v1 = 0;
		return;
	}

	int k = frame;

	while (panimvalue->num.total <= k)
	{
		k -= panimvalue->num.total;
		panimvalue += panimvalue->num.valid + 1;
		if ( panimvalue->num.total == 0 )
		{
			Assert( 0 ); // running off the end of the animation stream is bad
			v1 = 0;
			return;
		}
	}
	if (panimvalue->num.valid > k)
	{
		v1 = panimvalue[k+1].value * scale;
	}
	else
	{
		// get last valid data block
		v1 = panimvalue[panimvalue->num.valid].value * scale;
	}
}
*/
union mstudioanimvalue_t
{
	struct 
	{
        // unsigned because it is in some places
		unsigned char	valid; // number of valid frames, or how many frames of data this value has
		unsigned char	total; // total number of frames, aka "values"
	} num;
	short		value; // actual value, value*posscale
};

mstudioanimvalue_t ReadAnimValue(int pPos)
{
    local mstudioanimvalue_t studioanimvalue;

    studioanimvalue.value = ReadShort(pPos);
    
    //value.num.valid = ReadUByte(pPos);
    //value.num.total = ReadUByte(pPos + 1);

    return studioanimvalue;
}

/*struct animation_value_set(int isApex)
{
    mstudioanimvalue_t animvalue <fgcolor=0x99aaff>;
    short animation_data[animvalue.num.valid ? animvalue.num.valid - (1 * isApex) : animvalue.num.total] <fgcolor=0xf0f0ff>;
};

void GenerateAnimValues(int pAnimValue, int maxFrames)
{
    local int k = maxFrames;
    local int pCurrentPos = pAnimValue;    

    //Printf("remaining frames %i\n", k);

    while((ReadUByte(pCurrentPos) <= (k + isApex)) && (k > 0))
    {
        if(ReadUByte(pCurrentPos + 1) == 0)
            return;        

        FSeek(pCurrentPos);
        animation_value_set values(isApex);

        pCurrentPos += (values.animvalue.num.valid + (1 - isApex)) * sizeof(short);
        k -= values.animvalue.num.total;

        //Printf("remaining frames %i\n", k);
    }
}*/
struct frame_num{
    ubyte frame_valid;
    ubyte frame_total;
} ;

string FrameInfoStr(frame_num &f)
{
    local string s = byteItoA(f.frame_valid) + '/' + byteItoA(f.frame_total);
    return s;
}

string byteItoA(ubyte num){
    local int tenth = num/10;
    local int digit = num%10;
    local string r;
    SPrintf(r, "%c%c", tenth+48, digit+48);
    return  r;
    
}

string DivideBy256(short value)
{
    local float result = value / 256.0;
    local string s;
    SPrintf(s, "%.3f", result);
    return s;
}

void GenerateAnimValues(int pAnimValue, int maxFrames)
{
    local int k = maxFrames;
    local int pCurrentPos = pAnimValue;    

    //Printf("remaining frames %i\n", k);

    while(ReadUByte(pCurrentPos) <= k)
    {
        if(ReadUByte(pCurrentPos + 1) == 0)
            return;        

        FSeek(pCurrentPos);

        struct {
            frame_num fnum <hidden=true>;
            short animation_data[fnum.frame_valid] <read=DivideBy256>;
        } values <read=FrameInfoStr(fnum)>;

        pCurrentPos += (values.fnum.frame_valid + 1) * sizeof(short);
        k -= values.fnum.frame_total;

        //Printf("remaining frames %i\n", k);
    }
}


void ReadValuePtr(mstudioanim_valueptr_t &valueptr, int maxFrames)
{
    for(g = 0; g < 3; g++)
    {
        if(valueptr.offset[g])
            GenerateAnimValues(startof(valueptr) + valueptr.offset[g], maxFrames);
    }
}

// 'mstudioanim_t' in 48
struct mstudio_rle_anim_t
{
	ubyte bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // alien swarm/csgo says this is a signed int but that doesn't work well for our purposes.
	byte flags <read=ReadAnimFlags(this)>; // weighing options

    short nextoffset;

    if(flags & STUDIO_ANIM_ANIMROT)
        mstudioanim_valueptr_t pRotV;
	if(flags & STUDIO_ANIM_ANIMPOS)
	    mstudioanim_valueptr_t pPosV;
    if(flags & STUDIO_ANIM_ANIMSCALE)
	    mstudioanim_valueptr_t pScaleV;

	if(flags & STUDIO_ANIM_RAWROT)
	    Quaternion48 pQuat48;
	if(flags & STUDIO_ANIM_RAWROT2)
	    Quaternion64 pQuat64;
	if (flags & STUDIO_ANIM_RAWPOS)
	    Vector48 pPos;
    if (flags & STUDIO_ANIM_RAWSCALE)
	    Vector48 pScale;
};

// same as above but the struct is always the same size
struct mstudio_rle_anim_t_v53
{
	float posscale; // does what posscale is used for

	ubyte bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // unsigned byte, bone limit exceeds 128 so has to be. also means max bones is 255.
	byte flags <read=ReadAnimFlagsV53(this)>;

	short unk; // normally null data
               // honestly might just be fake to get the size to a clean 8 bytes
               // since the lower members are not actually part of the struct, at least in pre v52
	
    // using func names for var names
    if(flags & STUDIO_ANIM_RAWROT_53)
	    Quaternion64	pQuat64; // pQuat64
    else
    {
        mstudioanim_valueptr_t pRotV; // pRotV
        short pad;
    }

	if (flags & STUDIO_ANIM_RAWPOS_53)
	    Vector48 pPos; // pPos
    else
        mstudioanim_valueptr_t pPosV; // pPosV

    // scale track
    // a_Scaletest in pete_scripted for r1/2
    // drone_frag.mdl
    if (flags & STUDIO_ANIM_RAWSCALE_53)
	    Vector48 pScale;
    else
        mstudioanim_valueptr_t pScaleV;

	int nextoffset;
};

#define STUDIO_FRAME_RAWPOS		0x01 // Vector48 in constants
#define STUDIO_FRAME_RAWROT		0x02 // Quaternion48 in constants
#define STUDIO_FRAME_ANIMPOS	0x04 // Vector48 in framedata
#define STUDIO_FRAME_ANIMROT	0x08 // Quaternion48 in framedata
#define STUDIO_FRAME_FULLANIMPOS	0x10 // Vector in framedata

// v52 also has STUDIO_FRAME_RAWPOS & STUDIO_FRAME_RAWROT at the same values
// atlas_mp_scripted.mdl at_hotdrop_loop at_hotdrop_01
#define STUDIO_FRAME_RAWSCALE_52	0x04 // Vector48 in constants
#define STUDIO_FRAME_ANIMPOS_52	0x08 // Quaternion48 in framedata
#define STUDIO_FRAME_ANIMROT_52	0x10 // Vector48 in framedata
#define STUDIO_FRAME_ANIMSCALE_52	0x20 // Vector48 in framedata

// v52 frame flags:
// rawpos, rawrot, rawscale
// animpos, animrot, animscale

string ReadFrameAnimFlags(byte flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    byte flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case STUDIO_FRAME_RAWPOS:
            value += "STUDIO_FRAME_RAWPOS";
            break;
        case STUDIO_FRAME_RAWROT:
            value += "STUDIO_FRAME_RAWROT";
            break;
        case 0x4:
            if(hdr.version == 52)
                value += "STUDIO_FRAME_RAWSCALE_52";
            else
                value += "STUDIO_FRAME_ANIMPOS";
            break;
        case 0x8:
            if(hdr.version == 52)
                value += "STUDIO_FRAME_ANIMPOS_52";
            else
                value += "STUDIO_FRAME_ANIMROT";
            break;
        case 0x10:
            if(hdr.version == 52)
                value += "STUDIO_FRAME_ANIMROT_52";
            else
                value += "STUDIO_FRAME_FULLANIMPOS";
            break;
        case 0x20:
           if(hdr.version == 52)
                value += "STUDIO_FRAME_ANIMSCALE_52";
            else
                value += "UNK_0x20";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

struct mstudio_frame_anim_t
{
	int constantsoffset;

	int frameoffset;
	int framelength;

	int unused[3];
};

struct mstudio_frame_anim_t_v52
{
	int constantsoffset;

	int frameoffset;
	int framelength;

    int fixedOldBoneflags;

    int unkdataindex; // indexes into array of values that somewhat relate to flags

	int unused;
};

// per bone
struct unkframeanimdata_t
{
    short unkframe; // advances by six when bone has flags for frame data
    short unkconstant; // advances by six when bone has flags for constant data
};

// func to read these
#define STUDIO_X		0x00000001
#define STUDIO_Y		0x00000002	
#define STUDIO_Z		0x00000004
#define STUDIO_XR		0x00000008
#define STUDIO_YR		0x00000010
#define STUDIO_ZR		0x00000020

#define STUDIO_LX		0x00000040
#define STUDIO_LY		0x00000080
#define STUDIO_LZ		0x00000100
#define STUDIO_LXR		0x00000200
#define STUDIO_LYR		0x00000400
#define STUDIO_LZR		0x00000800

#define STUDIO_LINEAR	0x00001000

#define STUDIO_TYPES	0x0003FFFF
#define STUDIO_RLOOP	0x00040000	// controller that wraps shortest distance

struct mstudiomovement_t
{
	int					endframe;				
	int					motionflags;
	float				v0;			// velocity at start of block
	float				v1;			// velocity at end of block
	float				angle;		// YAW rotation at end of this blocks movement
	Vector				vector;		// movement vector relative to this blocks initial angle
	Vector				position;	// relative to start of animation???
};

// ik rule
#define IK_SELF 1
#define IK_WORLD 2
#define IK_GROUND 3
#define IK_RELEASE 4
#define IK_ATTACHMENT 5
#define IK_UNLATCH 6

string ReadIKRuleType(byte flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    switch(flags)
    {
    case 0:
        break;
    case IK_SELF:
        value += "IK_SELF";
        break;
    case IK_WORLD:
        value += "IK_WORLD";
        break;
    case IK_GROUND:
        value += "IK_GROUND";
        break;
    case IK_RELEASE:
        value += "IK_RELEASE";
        break;
    case IK_ATTACHMENT:
        value += "IK_ATTACHMENT";
        break;
    case IK_UNLATCH:
        value += "IK_UNLATCH";
        break;
    default:
        value += Str("UNK_%x", flag);
        break;
    }

    return value;
}

struct mstudioikrule_t
{
	int index;

	int type <read=ReadIKRuleType(this)>;
	int chain;

	int	bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;

	int slot;	// iktarget slot.  Usually same as chain.
	float height;
	float radius;
	float floor;
	Vector pos;
	Quaternion q;

	int compressedikerrorindex;
	
    int unused2;

	int iStart;
	int ikerrorindex;

	float start;	// beginning of influence
	float peak;	// start of full influence
	float tail;	// end of full influence
	float end;	// end of all influence

	float unused3;	// 
	float contact;	// frame footstep makes ground concact
	float drop;		// how far down the foot should drop when reaching for IK
	float top;		// top of the foot box

	int unused6;
	int unused7;
	int unused8;

	int szattachmentindex;		// name of world attachment

	int unused[7];
};

struct mstudioikrule_t_v52
{
	int index;

	int type <read=ReadIKRuleType(this)>;
	int chain;

	int	bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;

	int slot;	// iktarget slot.  Usually same as chain.
	float height;
	float radius;
	float floor;
	Vector pos;
	Quaternion q;

	int compressedikerrorindex;
	
    int unused2;

	int iStart;
	int ikerrorindex;

	float start;	// beginning of influence
	float peak;	// start of full influence
	float tail;	// end of full influence
	float end;	// end of all influence

	float unused3;	// 
	float contact;	// frame footstep makes ground concact
	float drop;		// how far down the foot should drop when reaching for IK
	float top;		// top of the foot box

	int unused6;
	int unused7;
	int unused8;

	int szattachmentindex;		// name of world attachment

    float endHeight; // new in v52

	int unused[6];
};


struct mstudioikrule_t_v53
{
    int index;
    int type <read=ReadIKRuleType(this)>;
    int chain;
    int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;

    int slot; // iktarget slot. Usually same as chain.
    float height;
    float radius;
    float floor;
    Vector pos;
    Quaternion q;

    int compressedikerrorindex;

    int iStart;
    int ikerrorindex;

    float start; // beginning of influence
    float peak; // start of full influence
    float tail; // end of full influence
    float end; // end of all influence

    float contact; // frame footstep makes ground concact
    float drop; // how far down the foot should drop when reaching for IK
    float top; // top of the foot box

    int szattachmentindex; // name of world attachment

    float endHeight; // new in v52
                     // titan_buddy_mp_core.mdl

    int unused[8];
};

// really think you need to read two sets of values for each offset, always seems to be a pair after
struct mstudiocompressedikerror_t
{
	float scale[6]; // these values are the same as what posscale (if it was used) and rotscale are.
	short offset[6];
};

// new in v52
// translation track for origin bone, used in lots of animated scenes, requires STUDIO_FRAMEMOVEMENT
// pos_x, pos_y, pos_z, yaw
struct mstudioframemovement_t
{
	float scale[4];
	short offset[4];
};

// v54 has offsets to the arry of four offset shorts, these are per section or only having one if it isn't
// a section based animation

// in the V54 version of this struct each offset goes to a struct(?) of eight bytes,
// the first int is an offset(?) to the data, the second is unknown

struct mstudioikerror_t
{
	Vector pos;
	Quaternion q;
};

struct mstudioikrulezeroframe_t
{
	short		chain;
	short		slot;
	hfloat		start;	// beginning of influence
	hfloat		peak;	// start of full influence
	hfloat		tail;	// end of full influence
	hfloat		end;	// end of all influence
};

// sequence descriptions
struct mstudioseqdesc_t_v48
{
	int baseptr;

	int	szlabelindex <read=ReadString(startof(this) + this - 4)>;

	int szactivitynameindex <read=ReadString(startof(this) + this - 8)>;

	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector bbmin; // per sequence bounding box
	Vector bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

	int unused[7];
};

struct mstudioseqdesc_t_v49
{
	int baseptr;

	int	szlabelindex <read=ReadString(startof(this) + this - 4)>;

	int szactivitynameindex <read=ReadString(startof(this) + this - 8)>;

	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector bbmin; // per sequence bounding box
	Vector bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
	int numactivitymodifiers;

	int unused[5];
};

struct mstudioseqdesc_t_v52
{
	int baseptr;

	int	szlabelindex <read=ReadString(startof(this) + this - 4)>;

	int szactivitynameindex <read=ReadString(startof(this) + this - 8)>;

	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector bbmin; // per sequence bounding box
	Vector bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
	int numactivitymodifiers;

    int ikResetMask; // new in v52
    int unk1; // count? STUDIO_ANIMDESC_52_UNK?? ikReset (what above var is masking)

	int unused[3];
};

struct mstudioseqdesc_t_v53
{
	int baseptr;

	int	szlabelindex <read=ReadString(startof(this) + this - 4)>;

	int szactivitynameindex <read=ReadString(startof(this) + this - 8)>;

	int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector bbmin; // per sequence bounding box
	Vector bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
	int numactivitymodifiers;

    int ikResetMask; // new in v52
                     // titan_buddy_mp_core.mdl
                     // reset all ikrules with this type???
    int unk1; // count? STUDIO_ANIMDESC_52_UNK??
              // mayhaps this is the ik type applied to the mask if what's above it true

	int unused[8];
};

struct posekey_t
{
    float unk[seqdesc[i].groupsize[0] + seqdesc[i].groupsize[1]];
};

#define OLD_EVENT_STYLE 0x0
#define NEW_EVENT_STYLE 0x400

string ReadEventFlags(int flags)
{
    string value = "";

    if(flags == 0)
        return "OLD_EVENT_STYLE";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x400:
            value += "NEW_EVENT_STYLE";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

// for 'int event'
// https://github.com/NicolasDe/AlienSwarm/blob/master/src/game/shared/scriptevent.h
// https://github.com/NicolasDe/AlienSwarm/blob/master/src/game/shared/eventlist.h
// https://github.com/NicolasDe/AlienSwarm/blob/master/src/game/shared/eventlist.h
struct mstudioevent_t
{
	float cycle;
	int	event;
	int type <read=ReadEventFlags(this)>; // this will be 0 if old style I'd imagine
	char options[64];

	int szeventindex <read=ReadString(startof(this) + this - 76)>;
};

// autolayer flags
//							0x0001
//							0x0002
//							0x0004
//							0x0008
#define STUDIO_AL_POST		0x0010		// 
//							0x0020
#define STUDIO_AL_SPLINE	0x0040		// convert layer ramp in/out curve is a spline instead of linear
#define STUDIO_AL_XFADE		0x0080		// pre-bias the ramp curve to compense for a non-1 weight, assuming a second layer is also going to accumulate
//							0x0100
#define STUDIO_AL_NOBLEND	0x0200		// animation always blends at 1.0 (ignores weight)
//							0x0400
//							0x0800
#define STUDIO_AL_LOCAL		0x1000		// layer is a local context sequence
#define STUDIO_AL_UNK_52	0x2000
#define STUDIO_AL_POSE		0x4000		// layer blends using a pose parameter instead of parent cycle
#define STUDIO_AL_UNK_53	0x8000		// added in v53 (probably)
                                        // I love this game I love this game I love this game I love this game I love this game I love this game

string ReadAutoLayerFlags(int flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x10:
            value += "STUDIO_AL_POST";
            break;
        case 0x40:
            value += "STUDIO_AL_SPLINE";
            break;
        case 0x80:
            value += "STUDIO_AL_XFADE";
            break;
        case 0x200:
            value += "STUDIO_AL_NOBLEND";
            break;
        case 0x1000:
            value += "STUDIO_AL_LOCAL";
            break;
        case 0x2000:
            value += "STUDIO_AL_UNK_52";
            break;
        case 0x4000:
            value += "STUDIO_AL_POSE";
            break;
        case 0x8000:
            value += "STUDIO_AL_UNK_53";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}


struct mstudioautolayer_t
{
	short iSequence <read=ReadString(startof(seqdesc[this]) + seqdesc[this].szlabelindex)>;
	short iPose;

	int flags <read=ReadAutoLayerFlags(this)>;
	float start;	// beginning of influence
	float peak;	// start of full influence
	float tail;	// end of full influence
	float end;	// end of all influence
};

// activity modifers are coniditions for the activity, e.g:
// if you have two sequences with ACT_RELOAD or such and one has an activity modifier for 'crouch',
// the activity modifier one with 'crouch' will only play when you are crouching an the other when you are not.
struct mstudioactivitymodifier_t
{	
	int sznameindex <read=ReadString(startof(this) + this)>;
};

struct mstudioactivitymodifier_t_v52
{	
	int sznameindex <read=ReadString(startof(this) + this)>;

    bool negate; // negate all other activity modifiers when this one is active?
};

// demand loaded sequence groups
struct mstudiomodelgroup_t
{
	int szlabelindex; // textual name
	int sznameindex <read=ReadString(startof(this) + this - 4)>; // file name
};


//===================
// Model/Mesh Structs


// body part index
struct mstudiobodyparts_t
{
	int sznameindex <read=ReadString(startof(this) + this)>;
	int nummodels;
	int base;
	int modelindex; // index into models array
};

// studio models
struct mstudio_modelvertexdata_t
{
	/*DECLARE_BYTESWAP_DATADESC();
	Vector				*Position( int i ) const;
	Vector				*Normal( int i ) const;
	Vector4D			*TangentS( int i ) const;
	Vector2D			*Texcoord( int i ) const;
	mstudioboneweight_t	*BoneWeights( int i ) const;
	mstudiovertex_t		*Vertex( int i ) const;
	bool				HasTangentData( void ) const;
	int					GetGlobalVertexIndex( int i ) const;
	int					GetGlobalTangentIndex( int i ) const;

	// base of external vertex data stores
	const void			*pVertexData;
	const void			*pTangentData;*/

    int pVertexData;
    int pTangentData;
};

struct mstudiomodel_t
{
	char name[64];

	int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
                     // offset by vertexindex number of bytes into vvd verts
	int tangentsindex; // tangents Vector
                       // offset by tangentsindex number of bytes into vvd tangents

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)

	int numattachments;
	int attachmentindex;

	int	numeyeballs;
	int eyeballindex;

	mstudio_modelvertexdata_t vertexdata;
    
	int unused[8]; // remove as appropriate
};

struct mstudiomodel_t_v52
{
	char name[64];

	int type;

	float boundingradius;

	int nummeshes;	
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
                     // offset by vertexindex number of bytes into vvd verts
	int tangentsindex; // tangents Vector
                       // offset by tangentsindex number of bytes into vvd tangents

	int numattachments;
	int attachmentindex;

	int deprecated_numeyeballs;
	int deprecated_eyeballindex;

	int pad[4];

    int colorindex; // vertex color
                    // offset by colorindex number of bytes into vvc vertex colors
    int uv2index; // vertex second uv map
                  // offset by uv2index number of bytes into vvc secondary uv map

    int unused[4];
};

// meshes
struct mstudio_meshvertexdata_t
{
    /*DECLARE_BYTESWAP_DATADESC();
	Vector				*Position( int i ) const;
	Vector				*Normal( int i ) const;
	Vector4D			*TangentS( int i ) const;
	Vector2D			*Texcoord( int i ) const;
	mstudioboneweight_t *BoneWeights( int i ) const;
	mstudiovertex_t		*Vertex( int i ) const;
	bool				HasTangentData( void ) const;
	int					GetModelVertexIndex( int i ) const;
	int					GetGlobalVertexIndex( int i ) const;

	// indirection to this mesh's model's vertex data
	const mstudio_modelvertexdata_t	*modelvertexdata;*/
    int modelvertexdata;

	int numLODVertexes[MAX_NUM_LODS];
};

struct mstudio_meshvertexloddata_t
{
    int modelvertexdataUnusedPad; // likely has none of the funny stuff because unused

	int numLODVertexes[MAX_NUM_LODS]; // depreciated starting with rmdl v14(?)
};

struct mstudiomesh_t
{
	int material <read=ReadString(startof(textures[this]) + textures[this].sznameindex)>;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t
                      // offset by vertexoffset number of verts into vvd vertexes, relative to the models offset

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)
	
	int numflexes; // vertex animation
	int flexindex;

	// special codes for material operations
	int materialtype;
	int materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector center;

	mstudio_meshvertexdata_t vertexdata;

	int unused[8]; // remove as appropriate
};

struct mstudiomesh_t_v52
{
	int material <read=ReadString(startof(textures[this]) + textures[this].sznameindex)>;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t
                      // offset by vertexoffset number of verts into vvd vertexes, relative to the models offset

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)
	
	int deprecated_numflexes; // vertex animation
	int deprecated_flexindex;

	// special codes for material operations
	int deprecated_materialtype;
	int deprecated_materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector center;

	mstudio_meshvertexloddata_t vertexloddata;

	int unused[8]; // remove as appropriate
};

struct mstudiomesh_t_v53
{
	int material <read=ReadString(startof(textures[this]) + textures[this].sznameindex)>;

	int modelindex;

	int numvertices; // number of unique vertices/normals/texcoords
	int vertexoffset; // vertex mstudiovertex_t
                      // offset by vertexoffset number of verts into vvd vertexes, relative to the models offset

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)
	
	int deprecated_numflexes; // vertex animation
	int deprecated_flexindex;

	// special codes for material operations
	int deprecated_materialtype;
	int deprecated_materialparam;

	// a unique ordinal for this mesh
	int meshid;

	Vector center;

	mstudio_meshvertexloddata_t vertexloddata;
    
    char unk[8]; // set on load

	int unused[6]; // remove as appropriate
};


//=================
// Material Structs


// cdmaterials
struct mstudiotexturedir_t
{
	int sznameindex <read=ReadString(this)>; // file name
};

// skin info
struct mstudiotexture_t
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int flags;
	int used;
    int unused1;
	
    // these are turned into 64 bit ints on load and only filled in memory
    int material_RESERVED;
    int clientmaterial_RESERVED;

    int unused[10];
};

struct mstudiotexture_t_v52
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int unused_flags;
	int used;
    int unused1;
	
    // these are turned into 64 bit ints on load and only filled in memory
    int material_RESERVED;
    int clientmaterial_RESERVED;

    int unused[10];
};

struct mstudiotexture_t_v53
{
	int sznameindex <read=ReadString(startof(this) + this)>;

	int unused_flags;
	int used;

	int unused[8];
};


//====
// RUI


struct mstudiorruiheader_t
{
    int namehash; // uses rui hash algo
    int ruimeshindex; // offset to the actual rui mesh
};

// vertex map for a face
struct mstudioruivertmap_t
{
    // order of vertices for triangles:
    // 1st tri: 1-3-2
    // 2nd tri: 4-2-3

    // sometimes these are for a triangle instead of a quad, if that's the case then:
    // tri: 1-4-2
    // in this case the vert map will only cover 3 verts.

    
    // in v53 the first two are an array like such:
    // 1-3
    // while the third is the fourth vert.
    short vertid[3];
};

struct mstudioruivert_t
{
    int parent; // relative to global mesh parent, assumed

    Vector vertexpos; // position of vertex relative to bone
};

struct mstudioruimeshface_t
{
    // this might be the same as the RPak UIMG UV struct.

    // these values are for the two vertices that are not shared
    // for the other do as such:
    // vertex 2: take x from vextex 1 and y from vextex 4
    // vertex 2: take x from vextex 4 and y from vextex 1

    // normal smd uv, seems to calculate for other values
    Vector2 faceuvmin; // vertex 1
    Vector2 faceuvmax; // vertex 4

    // these could likely be calculated by doing math with a height/width scale
    // scale of the ui element
    Vector2 facescalemin; // vertex 1
    Vector2 facescalemax; // vertex 4
};

struct mstudioruimesh_t
{
    int numparents; // apparently you can have meshes parented to more than one bone(?)    
    int numvertices; // number of verts
    int numfaces; // number of faces

    int parentindex; // this gets padding out front of it to even off the struct

    int vertexindex; // offset into smd style vertex data
    int vertmapindex; // offsets into a vertex map for each quad
    int facedataindex; // offset into uv section

    DWORD unk; // zero sometimes, others not. has to do with face clipping.
};


//=======================
// Per Triangle Collision

struct mstudiopertrihdr_t
{
	short version; // game requires this to be 2 or else it errors

	short unk; // may or may not exist, version gets casted as short in ida

	Vector bbmin;
	Vector bbmax;

	int unused[8];
};

struct mstudiopertrinode_t
{
    // bounds? probably calculated the same as vert pos. needs to be checked
    short min[3];
    short max[3];
    
    // sometimes negative
    // node / leaf indices, zero or greater is node, neg one or less is leaf
    // real leaf index is (index * -1) - 1
    int child0Index;
    int child1Index;
};

struct mstudiopertrileaftri_t
{
    short vertIndices[3];
    short unk;
};

struct mstudiopertrileaf_t
{
    // bounds? probably calculated the same as vert pos. needs to be checked
    short min[3];
    short max[3];

    int unk1; // padding for 16 byte alignment?
    
    mstudiopertrileaftri_t triangles[12];
};

struct mstudiopertrivertex_t
{
	// to get float value:
	// axisValue * ((float)(bbmax.axis - bbmin.axis) * 0.000015259022)
	// where axis is x, y, or z. bbmax and bbmin are from the pertri header.
	short x <read=Str("%f", this * ((float)(pertrihdr.bbmax.x - pertrihdr.bbmin.x) * 0.000015259022))>; 
    short y <read=Str("%f", this * ((float)(pertrihdr.bbmax.y - pertrihdr.bbmin.y) * 0.000015259022))>;
    short z <read=Str("%f", this * ((float)(pertrihdr.bbmax.z - pertrihdr.bbmin.z) * 0.000015259022))>;
};

//========
// Unknown


// struct near end of file.
struct mstudiocollisionhdr_t
{
    int faceCount;
    int unkCount; // quaternion, edges?
    int edgeCount; // face edges
    int vertCount;

    int dataOffset; //
};

struct mstudiocollisionedge_t
{
    Vector vertPos[2];
    unsigned char vertIndices[2];
    unsigned char faceIndices[2];
};


//=====
// Misc


struct mstudionodename_t
{
    int sznameindex <read=ReadString(this)>;
};

struct mstudionodedata
{
    byte nodedata[hdr.numlocalnodes];
};
//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: rmdl, rrig
//   Authors: Valve, Respawn, Rika, & Others
//   Version: 54
//   Purpose: Respawn MDL Structs
//  Category: Struct
// File Mask: *.rmdl, *.rrig
//  ID Bytes: 
//   History: 
//------------------------------------------------

#define MAX_NUM_LODS 8
typedef Vector Vector;

//local int i = 0;

// these are just all structs that I have mostly working/fitting, it does not mean they are correct.
// a lot of these are from either valvedevwiki, the public source sdk 2013 code, and crowbar.

//==================
// Generic Functions

int GetRMDLOffset(unsigned short offset)
{
    local int fixedOffset = ((offset & 0xFFFE) << (4 * (offset & 1)));

    return fixedOffset;
}

// whar
/*int GetMDLString(int index)
{
    local int relativeIndex = startof(parentof(index)) + index;

    return relativeIndex;
}*/

//========
// Headers


// main headers
// note: rrigs do not have a checksum
// note: surfaceproplookup seems to be written in later versions?
struct studiohdr_t_v54
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    int sznameindex <read=ReadString(this)>; // This has been moved from studiohdr2 to the front of the main header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

    Vector illumposition;	// illumination center
    
    Vector hull_min;		// ideal movement hull size
    Vector hull_max;			

    Vector view_bbmin;		// clipping bounding box
    Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
    int boneindex;
 
    int numbonecontrollers; // bone controllers
    int bonecontrollerindex;
 
    int numhitboxsets;
    int hitboxsetindex;
 
    // unused now
    int numlocalanim; // animations/poses
    int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
    int	localseqindex;
 
    int activitylistversion; // initialization flag - have the sequences been indexed?
 
    // mstudiotexture_t
    // short rpak path
    // raw textures
    int materialtypesindex; // index into an array of byte sized material type enums for each material used by the model
    int numtextures; // the material limit exceeds 128, probably 256.
    int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
    int numcdtextures;
    int cdtextureindex;
 
    // replaceable textures tables
    int numskinref;
    int numskinfamilies;
    int skinindex;
 
    int numbodyparts;		
    int bodypartindex;
 
    int numlocalattachments;
    int localattachmentindex;
 
    int numlocalnodes;
    int localnodeindex;
    int localnodenameindex;
 
    int numunknodes; // ???
    int nodedataindexindex; // index into an array of int sized offsets that read into the data for each node
 
    int meshindex; // offset to model meshes

    // all flex related model vars and structs are stripped in respawn source
    int deprecated_numflexcontrollers;
    int deprecated_flexcontrollerindex;
 
    int deprecated_numflexrules;
    int deprecated_flexruleindex;
 
    int numikchains;
    int ikchainindex;

    // mesh panels for using rui on models, primarily for weapons
    int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
    int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
    int keyvaluesize;
 
    int numlocalikautoplaylocks;
    int localikautoplaylockindex;
 
    float mass;
    int contents <read=ReadContents(this)>;
    
    // unused for packed models
    // technically still functional though I am unsure why you'd want to use it
    int numincludemodels;
    int includemodelindex;
    
    int virtualModel; // size placeholder

    int bonetablebynameindex;
    
    // if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
    // this value is used to calculate directional components of lighting 
    // on static props
    byte constdirectionallightdot;

    // set during load of mdl data to track *desired* lod configuration (not actual)
    // the *actual* clamped root lod is found in studiohwdata
    // this is stored here as a global store to ensure the staged loading matches the rendering
    byte rootLOD;
    
    // set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
    // to be set as root LOD:
    //	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
    //	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
    byte numAllowedRootLODs;

    byte unused;

    float fadeDistance;
    
    float gathersize; // what. from r5r struct

    int deprecated_numflexcontrollerui;
    int deprecated_flexcontrolleruiindex;

    float flVertAnimFixedPointScale; // to be verified
    int surfacepropLookup; // saved in the file

    int sourceFilenameOffset; // doesn't actually need to be written pretty sure, only four bytes when not present.

    int numsrcbonetransform;
    int srcbonetransformindex;

    int	illumpositionattachmentindex;
    
    int linearboneindex;

    // unsure what this is for but it exists for jigglbones
    int numprocbones;
    int procbonetableindex;
    int linearprocboneindex;

    // depreciated as they are removed in 12.1
    int m_nBoneFlexDriverCount;
    int m_nBoneFlexDriverIndex;
    
    int m_nPerTriAABBIndex;
    int m_nPerTriAABBNodeCount;
    int m_nPerTriAABBLeafCount;
    int m_nPerTriAABBVertCount;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(hdr.unkstringindex)>;

    // this is now used for combined files in rpak, vtx, vvd, and vvc are all combined while vphy is separate.
    // the indexes are added to the offset in the rpak mdl_ header.
    // vphy isn't vphy, looks like a heavily modified vphy.
    int vtxindex; // VTX
    int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize;
    int vvdsize;
    int vvcsize;
    int vphysize; // still used in models using vg

    // unused in apex, gets cut in 12.1
    int unkmemberindex1;
    int numunkmember1;

    // mostly seen on '_animated' suffixed models
    // manually declared bone followers are no longer stored in kvs under 'bone_followers', they are now stored in an array of ints with the bone index.
    int numbonefollowers; // numBoneFollowers
    int bonefollowerindex;

    // BVH4 size (?)
    Vector mins;
    Vector maxs; // seem to be the same as hull size

    int unk3_v54[3];

    int bvh4index; // bvh4 tree

    short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

    // new in apex vertex weight file for verts that have more than three weights
    int vvwindex; // index will come last after other vertex files
    int vvwsize;
};

struct studiohdr_t_v54_v121
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    int sznameindex <read=ReadString(this)>; // This has been moved from studiohdr2 to the front of the main header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

    Vector illumposition;	// illumination center
    
    Vector hull_min;		// ideal movement hull size
    Vector hull_max;			

    Vector view_bbmin;		// clipping bounding box
    Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
    int boneindex;
 
    int numbonecontrollers; // bone controllers
    int bonecontrollerindex;
 
    int numhitboxsets;
    int hitboxsetindex;
 
    // unused now
    int numlocalanim; // animations/poses
    int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
    int	localseqindex;
 
    int activitylistversion; // initialization flag - have the sequences been indexed?
 
    // mstudiotexture_t
    // short rpak path
    // raw textures
    int materialtypesindex;
    int numtextures; // the material limit exceeds 128, probably 256.
    int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
    int numcdtextures;
    int cdtextureindex;
 
    // replaceable textures tables
    int numskinref;
    int numskinfamilies;
    int skinindex;
 
    int numbodyparts;		
    int bodypartindex;
 
    int numlocalattachments;
    int localattachmentindex;
 
    int numlocalnodes;
    int localnodeindex;
    int localnodenameindex;
 
    int numunknodes;
    int nodedataindexindex;

    int numikchains;
    int ikchainindex;
 
    // this is rui meshes
    int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
    int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
    int keyvaluesize;
 
    int numlocalikautoplaylocks;
    int localikautoplaylockindex;
 
    float mass;
    int contents <read=ReadContents(this)>;
    
    // unused for packed models
    int numincludemodels;
    int includemodelindex;
    
    uint32 virtualModel;

    int bonetablebynameindex;

    // stuff moved from vg in v12.1
    int numVGMeshes; // total number of meshes, not including LODs
    int vgMeshIndex;

    int boneStateIndex;
    int numBoneStates;

    int unk_v54_v121; // related to vg likely

    int vgSize;

    short vgUnk; // same as padding in vg header
    short vgLODCount; // same as lod count in vg header

    int vgNumUnknown; // same as unk1 in vg header

    int vgHeaderIndex;
    int numVGHeaders;

    int vgLODIndex;
    int numVGLODs;

    float fadeDistance;
    
    float gathersize; // what. from r5r struct
    
    float flVertAnimFixedPointScale; // to be verified
    int surfacepropLookup; // saved in the file

    // asset bakery strings if it has any
    int sourceFilenameOffset;

    int numsrcbonetransform;
    int srcbonetransformindex;

    int	illumpositionattachmentindex;

    int linearboneindex;

    // unsure what this is for but it exists for jigglbones
    int numprocbonesunk;
    int procbonearrayindex;	
    int procbonemaskindex;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(hdr.unkstringindex)>;

    // the indexes are added to the offset in the rpak mdl_ header.
    // vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
    int vtxindex; // VTX
    int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize;
    int vvdsize;
    int vvcsize;
    int vphysize;

    // mostly seen on '_animated' suffixed models
    // manually declared bone followers are no longer stored in kvs under 'bone_followers', they are now stored in an array of ints with the bone index.
    int numbonefollowers; // numBoneFollowers
    int bonefollowerindex;

    // BVH4 size (?)
    Vector mins;
    Vector maxs; // seem to be the same as hull size

    int bvh4index; // bvh4 tree

    short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

    int vvwindex;
    int vvwsize;
};

struct studiohdr_t_v54_v122
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    int sznameindex <read=ReadString(this)>; // This has been moved from studiohdr2 to the front of the main header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

    Vector illumposition;	// illumination center
    
    Vector hull_min;		// ideal movement hull size
    Vector hull_max;			

    Vector view_bbmin;		// clipping bounding box
    Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
    int boneindex;
 
    int numbonecontrollers; // bone controllers
    int bonecontrollerindex;
 
    int numhitboxsets;
    int hitboxsetindex;
 
    // unused now
    int numlocalanim; // animations/poses
    int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
    int	localseqindex;
 
    int activitylistversion; // initialization flag - have the sequences been indexed?
 
    // mstudiotexture_t
    // short rpak path
    // raw textures
    int materialtypesindex;
    int numtextures; // the material limit exceeds 128, probably 256.
    int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
    int numcdtextures;
    int cdtextureindex;
 
    // replaceable textures tables
    int numskinref;
    int numskinfamilies;
    int skinindex;
 
    int numbodyparts;		
    int bodypartindex;
 
    int numlocalattachments;
    int localattachmentindex;
 
    int numlocalnodes;
    int localnodeindex;
    int localnodenameindex;
 
    int numunknodes;
    int nodedataindexindex;

    int numikchains;
    int ikchainindex;
 
    // this is rui meshes
    int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
    int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
    int keyvaluesize;
 
    int numlocalikautoplaylocks;
    int localikautoplaylockindex;
 
    float mass;
    int contents <read=ReadContents(this)>;
    
    // unused for packed models
    int numincludemodels;
    int includemodelindex;
    
    uint32 virtualModel;

    int bonetablebynameindex;

    // stuff moved from vg in v12.1
    int numVGMeshes; // total number of meshes, not including LODs
    int vgMeshIndex;

    int boneStateIndex;
    int numBoneStates;

    int unk_v54_v121; // related to vg likely

    int vgSize;

    short vgUnk; // same as padding in vg header
    short vgLODCount; // same as lod count in vg header

    int vgNumUnknown; // same as unk1 in vg header

    int vgHeaderIndex;
    int numVGHeaders;

    int vgLODIndex;
    int numVGLODs;

    float fadeDistance;
    
    float gathersize; // what. from r5r struct
    
    float flVertAnimFixedPointScale; // to be verified
    int surfacepropLookup; // saved in the file

    int unk_v54_v122; // added in transition version

    // asset bakery strings if it has any
    int sourceFilenameOffset;

    int numsrcbonetransform;
    int srcbonetransformindex;

    int	illumpositionattachmentindex;

    int linearboneindex;

    // unsure what this is for but it exists for jigglbones
    int numprocbonesunk;
    int procbonearrayindex;	
    int procbonemaskindex;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(hdr.unkstringindex)>;

    // the indexes are added to the offset in the rpak mdl_ header.
    // vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
    int vtxindex; // VTX
    int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize;
    int vvdsize;
    int vvcsize;
    int vphysize;

    // mostly seen on '_animated' suffixed models
    // manually declared bone followers are no longer stored in kvs under 'bone_followers', they are now stored in an array of ints with the bone index.
    int numbonefollowers; // numBoneFollowers
    int bonefollowerindex;

    // BVH4 size (?)
    Vector mins;
    Vector maxs; // seem to be the same as hull size

    int bvh4index; // bvh4 tree

    short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

    int vvwindex;
    int vvwsize;
};

struct studiohdr_t_v54_v13
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    int sznameindex <read=ReadString(this)>; // This has been moved from studiohdr2 to the front of the main header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

    Vector illumposition;	// illumination center
    
    Vector hull_min;		// ideal movement hull size
    Vector hull_max;			

    Vector view_bbmin;		// clipping bounding box
    Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
    int boneindex;
 
    int numbonecontrollers; // bone controllers
    int bonecontrollerindex;
 
    int numhitboxsets;
    int hitboxsetindex;
 
    // unused now
    int numlocalanim; // animations/poses
    int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
    int	localseqindex;
 
    int activitylistversion; // initialization flag - have the sequences been indexed?
 
    // mstudiotexture_t
    // short rpak path
    // raw textures
    int materialtypesindex;
    int numtextures; // the material limit exceeds 128, probably 256.
    int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
    int numcdtextures;
    int cdtextureindex;
 
    // replaceable textures tables
    int numskinref;
    int numskinfamilies;
    int skinindex;
 
    int numbodyparts;		
    int bodypartindex;
 
    int numlocalattachments;
    int localattachmentindex;
 
    int numlocalnodes;
    int localnodeindex;
    int localnodenameindex;
 
    int numunknodes;
    int nodedataindexindex;

    int numikchains;
    int ikchainindex;
 
    // this is rui meshes
    int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
    int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
    int keyvaluesize;
 
    int numlocalikautoplaylocks;
    int localikautoplaylockindex;
 
    float mass;
    int contents <read=ReadContents(this)>;
    
    // unused for packed models
    int numincludemodels;
    int includemodelindex;
    
    uint32 virtualModel;

    int bonetablebynameindex;

    // stuff moved from vg in v12.1
    int numVGMeshes; // total number of meshes, not including LODs
    int vgMeshIndex;

    int boneStateIndex;
    int numBoneStates;

    int unk_v54_v121; // related to vg likely

    int vgSize;

    short vgUnk; // same as padding in vg header
    short vgLODCount; // same as lod count in vg header

    int vgNumUnknown; // same as unk1 in vg header

    int vgHeaderIndex;
    int numVGHeaders;

    int vgLODIndex;
    int numVGLODs;

    float fadeDistance;
    
    float gathersize; // what. from r5r struct
    
    float flVertAnimFixedPointScale; // to be verified
    int surfacepropLookup; // saved in the file

    int unk_v54_v122; // added in transition version

    // asset bakery strings if it has any
    int sourceFilenameOffset;

    int numsrcbonetransform;
    int srcbonetransformindex;

    int	illumpositionattachmentindex;

    int linearboneindex;

    // unsure what this is for but it exists for jigglbones
    int numprocbonesunk;
    int procbonearrayindex;	
    int procbonemaskindex;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(hdr.unkstringindex)>;

    // the indexes are added to the offset in the rpak mdl_ header.
    // vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
    int vtxindex; // VTX
    int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize;
    int vvdsize;
    int vvcsize;
    int vphysize;

    // mostly seen on '_animated' suffixed models
    // manually declared bone followers are no longer stored in kvs under 'bone_followers', they are now stored in an array of ints with the bone index.
    int numbonefollowers; // numBoneFollowers
    int bonefollowerindex;

    // BVH4 size (?)
    Vector mins;
    Vector maxs; // seem to be the same as hull size

    int bvh4index; // bvh4 tree

    short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

    int vvwindex;
    int vvwsize;

    int unk1_v54_v13[3];
};

struct studiohdr_t_v54_v14
{
    int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
    int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
    int checksum; // This has to be the same in the phy and vtx files to load!
    int sznameindex <read=ReadString(this)>; // No longer stored in string block, uses string in header.
    char name[64]; // The internal name of the model, padding with null bytes.
                    // Typically "my_model.mdl" will have an internal name of "my_model"
    int length; // Data size of MDL file in bytes.
 
    Vector eyeposition;	// ideal eye position

    Vector illumposition;	// illumination center
    
    Vector hull_min;		// ideal movement hull size
    Vector hull_max;			

    Vector view_bbmin;		// clipping bounding box
    Vector view_bbmax;		
 
    int flags <read=ReadHeaderFlags(this)>;
  
    int numbones; // bones
    int boneindex;
 
    int numbonecontrollers; // bone controllers
    int bonecontrollerindex;
 
    int numhitboxsets;
    int hitboxsetindex;
 
    // unused now
    int numlocalanim; // animations/poses
    int localanimindex; // animation descriptions
 
    int numlocalseq; // sequences
    int	localseqindex;

    int unk_v54_v14[2]; // added in v13 -> v14
 
    int activitylistversion; // initialization flag - have the sequences been indexed?
 
    // mstudiotexture_t
    // short rpak path
    // raw textures
    int materialtypesindex;
    int numtextures; // the material limit exceeds 128, probably 256.
    int textureindex;
 
    // this should always only be one, unless using vmts.
    // raw textures search paths
    int numcdtextures;
    int cdtextureindex;
 
    // replaceable textures tables
    int numskinref;
    int numskinfamilies;
    int skinindex;
 
    int numbodyparts;		
    int bodypartindex;
 
    int numlocalattachments;
    int localattachmentindex;
 
    int numlocalnodes;
    int localnodeindex;
    int localnodenameindex;
 
    int numunknodes;
    int nodedataindexindex;

    int numikchains;
    int ikchainindex;
 
    // this is rui meshes
    int numruimeshes;
    int ruimeshindex;
 
    int numlocalposeparameters;
    int localposeparamindex;
 
    int surfacepropindex <read=ReadString(this)>;
 
    int keyvalueindex;
    int keyvaluesize;
 
    int numlocalikautoplaylocks;
    int localikautoplaylockindex;
 
    float mass;
    int contents <read=ReadContents(this)>;
    
    // unused for packed models
    int numincludemodels;
    int includemodelindex;
    
    uint32 virtualModel;

    int bonetablebynameindex;

    // stuff moved from vg in v12.1
    int numVGMeshes; // total number of meshes, not including LODs
    int vgMeshIndex;

    int boneStateIndex;
    int numBoneStates;

    int unk_v54_v121; // related to vg likely

    int vgSize;

    short vgUnk; // same as padding in vg header
    short vgLODCount; // same as lod count in vg header

    int vgNumUnknown; // same as unk1 in vg header

    int vgHeaderIndex;
    int numVGHeaders;

    int vgLODIndex;
    int numVGLODs;

    float fadeDistance;
    
    float gathersize; // what. from r5r struct
    
    float flVertAnimFixedPointScale; // to be verified
    int surfacepropLookup; // saved in the file

    int unk_v54_v122; // added in transition version

    // asset bakery strings if it has any
    int sourceFilenameOffset;

    int numsrcbonetransform;
    int srcbonetransformindex;

    int	illumpositionattachmentindex;

    int linearboneindex;

    // unsure what this is for but it exists for jigglbones
    int numprocbonesunk;
    int procbonearrayindex;	
    int procbonemaskindex;

    // always "" or "Titan"
    int unkstringindex <read=ReadString(hdr.unkstringindex)>;

    // the indexes are added to the offset in the rpak mdl_ header.
    // vphy isn't vphy, looks like a heavily modified vphy.
    // something different about these now
    int vtxindex; // VTX
    int vvdindex; // VVD / IDSV
    int vvcindex; // VVC / IDCV 
    int vphyindex; // VPHY / IVPS

    int vtxsize;
    int vvdsize;
    int vvcsize;
    int vphysize;

    // mostly seen on '_animated' suffixed models
    // manually declared bone followers are no longer stored in kvs under 'bone_followers', they are now stored in an array of ints with the bone index.
    int numbonefollowers; // numBoneFollowers
    int bonefollowerindex;

    // BVH4 size (?)
    Vector mins;
    Vector maxs; // seem to be the same as hull size

    int bvh4index; // bvh4 tree

    short unk4_v54[2]; // same as unk3_v54_v121, 2nd might be base for other offsets?

    int vvwindex;
    int vvwsize;

    int unk1_v54_v13[3];
};

struct studiohdr_t_v16
{
    int flags <read=ReadHeaderFlags(this)>;
    int checksum; // unsure if this is still checksum, there isn't any other files that have it still
    short sznameindex <read=ReadString(this)>; // No longer stored in string block, uses string in header.
    char name[32]; // The internal name of the model, padding with null bytes.
                   // Typically "my_model.mdl" will have an internal name of "my_model"
    byte unk_v16;

    byte surfacepropLookup; // saved in the file
 
    float mass;

    int version; // time will tell

    unsigned short hitboxsetindex;
    byte numhitboxsets;

    byte illumpositionattachmentindex;

    Vector illumposition;	// illumination center
    
    Vector hull_min;		// ideal movement hull size
    Vector hull_max;			

    Vector view_bbmin;		// clipping bounding box
    Vector view_bbmax;		
  
    short numbones; // bones
    unsigned short boneindex;
    unsigned short bonedataindex;

    short numlocalseq; // sequences
    unsigned short localseqindex;

    //byte unkfill[5];

    // needs to be confirmed
    short unk_v54_v14[2]; // added in v13 -> v14
 
    // needs to be confirmed
    byte activitylistversion; // initialization flag - have the sequences been indexed?

    byte numlocalattachments;
    unsigned short localattachmentindex;

    short numlocalnodes;
    unsigned short localnodenameindex;
    unsigned short nodedataindexindex;

    short numikchains;
    unsigned short ikchainindex;

    short numtextures; // the material limit exceeds 128, probably 256.
    unsigned short textureindex;

    // replaceable textures tables
    short numskinref;
    short numskinfamilies;
    unsigned short skinindex;

    short numbodyparts;		
    unsigned short bodypartindex;

    // this is rui meshes
    short numruimeshes;
    unsigned short ruimeshindex;

    short numlocalposeparameters;
    unsigned short localposeparamindex;

    unsigned short surfacepropindex <read=ReadString(this)>;

    unsigned short keyvalueindex;

    // vg stuff 1
    unsigned short numVGMeshes; // total number of meshes, not including LODs
    short vgMeshIndex;

    short bonetablebynameindex;

    // vg stuff 2
    unsigned short boneStateIndex;
    short numBoneStates;

    unsigned short vgHeaderIndex;
    short numVGHeaders;

    unsigned short vgLODIndex;
    short numVGLODs;

    float fadeDistance;
    
    float gathersize; // what. from r5r struct

    short numsrcbonetransform;
    unsigned short srcbonetransformindex;

    // asset bakery strings if it has any
    short sourceFilenameOffset;

    unsigned short linearboneindex;

    // unsure what this is for but it exists for jigglbones
    unsigned short numprocbones;
    unsigned short procbonetableindex;
    unsigned short linearprocboneindex;

    // mostly seen on '_animated' suffixed models
    // manually declared bone followers are no longer stored in kvs under 'bone_followers', they are now stored in an array of ints with the bone index.
    short numbonefollowers; // numBoneFollowers
    unsigned short bonefollowerindex;

    unsigned short bvh4index; // same as v54

    byte unk5_v16; // unk4_v54[0]
    byte unk6_v16; // unk4_v54[1]
    short unk7_v16; // unk4_v54[2]
    short unk8_v16;
    short unk9_v16;

    //unsigned short unkshorts[7];
};

//=============
// Bone Structs


// bones
// v54 is a heavily gutted v53 bone
struct mstudiobone_t_v54
{
    int sznameindex <read=ReadString(startof(this) + this)>;

    int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
    int bonecontroller[6]; // bone controller index, -1 == none

    // default values
    Vector pos;
    Quaternion quat;
    RadianEuler rot;
    Vector scale; // bone scale(?)

    matrix3x4_t poseToBone;
    Quaternion qAlignment;

    int flags <read=ReadBoneFlags(this)>;
    int proctype;
    int procindex; // procedural rule
    int physicsbone; // index into physically simulated bone
    
    int surfacepropidx <read=ReadString(startof(this) + this - 164)>; // index into string tablefor property name

    int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags
    
    int surfacepropLookup; // written on compile in v54

    int unk;
    
    int unkid; // physics index (?)
};

struct mstudiobone_t_v54_v121
{
    int sznameindex <read=ReadString(startof(this) + this)>;

    int parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone
    int bonecontroller[6]; // bone controller index, -1 == none

    // default values
    Vector pos;
    Quaternion quat;
    RadianEuler rot;	
    Vector scale; // bone scale(?)

    matrix3x4_t poseToBone;
    Quaternion qAlignment;

    int flags <read=ReadBoneFlags(this)>;
    int proctype <read=ReadProcFlags(this)>;
    int procindex; // procedural rule
    int physicsbone; // index into physically simulated bone
    
    int surfacepropidx <read=ReadString(startof(this) + this - 164)>; // index into string tablefor property name

    int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags
    
    int surfacepropLookup; // written on compile in v54

    byte unkid; // this is separate because it's set to 0xFF when unused (-1)

    byte unk1[3]; // maybe this is 'unk'?
};

struct mstudiobone_t_v16
{
    int contents <read=ReadContents(this)>; // See BSPFlags.h for the contents flags

    byte unk;

    byte surfacepropLookup; // written on compile in v54

    short surfacepropidx <read=ReadString(startof(this) + this - 6)>; // index into string tablefor property name

    short physicsbone; // index into physically simulated bone

    short sznameindex <read=ReadString(startof(this) + this - 10)>;
};

struct mstudiobonedata_t_v16
{
    matrix3x4_t poseToBone;
    Quaternion qAlignment;

    // default values
    Vector pos;
    Quaternion quat;
    RadianEuler rot;
    Vector scale; // bone scale(?)

    short parent <read=ReadString(startof(bones[ReadParentBone(this)]) + bones[ReadParentBone(this)].sznameindex)>; // parent bone;

    short unk1;

    int flags <read=ReadBoneFlags(this)>;

    byte unkid;

    byte proctype <read=ReadProcFlags(this)>;
    unsigned short procindex; // procedural rule
};

// jigglebone
struct mstudiojigglebone_t_v54
{
    byte flags <read=ReadJiggleFlags(this)>; // looks to be.

    ubyte bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // id of bone, might be single byte

    short pad; // possibly unused

    // general params
    float length; // how far from bone base, along bone, is tip
    float tipMass;

    float unkfloat; // v54 adds an extra value here but otherwise the same
                    // observed values are between 0-1

    // flexible params
    float yawStiffness;
    float yawDamping;	
    float pitchStiffness;
    float pitchDamping;	
    float alongStiffness;
    float alongDamping;	

    // angle constraint
    float angleLimit; // maximum deflection of tip in radians
    
    // yaw constraint
    float minYaw; // in radians
    float maxYaw; // in radians
    float yawFriction;
    float yawBounce;
    
    // pitch constraint
    float minPitch; // in radians
    float maxPitch; // in radians
    float pitchFriction;
    float pitchBounce;

    // base spring
    float baseMass;
    float baseStiffness;
    float baseDamping;	
    float baseMinLeft;
    float baseMaxLeft;
    float baseLeftFriction;
    float baseMinUp;
    float baseMaxUp;
    float baseUpFriction;
    float baseMinForward;
    float baseMaxForward;
    float baseForwardFriction;
};

// attachment
struct mstudioattachment_t_v54
{
    int sznameindex <read=ReadString(startof(this) + this)>;
    int flags;

    int localbone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // parent bone

    matrix3x4_t			localmatrix; // attachment point
};

struct mstudioattachment_t_v16
{
    short sznameindex <read=ReadString(startof(this) + this)>;
    short localbone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>; // parent bone
    int flags;

    matrix3x4_t			localmatrix; // attachment point
};

// ikchain
struct mstudioikchain_t_v54
{
    int sznameindex <read=ReadString(startof(this) + this)>;

    int linktype;
    int numlinks;
    int linkindex;
    
    float unk; // no clue what this does tbh, tweaking it does nothing
               // default value: 0.707f
};

struct mstudioikchain_t_v16
{
    unsigned short sznameindex <read=ReadString(startof(this) + this)>;

    short linktype;
    short numlinks;
    unsigned short linkindex;
    
    float unk; // no clue what this does tbh, tweaking it does nothing
               // default value: 0.707f
};

// ikinfo
struct mstudioiklink_t_v54
{
    int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
    Vector	kneeDir; // no kneeDir in apex I think
};

// linear bone

struct mstudiolinearbone_t_v54
{
    // they cut pos and rot scale, understandable since posscale was never used it tf|2 and they do anims different in apex
    int numbones;

    int flagsindex;

    int	parentindex;
    
    int	posindex;
    
    int quatindex;
    
    int rotindex;
    
    int posetoboneindex;
};

struct mstudiolinearbone_t_v16
{
    // they cut pos and rot scale, understandable since posscale was never used it tf|2 and they do anims different in apex
    short numbones;

    short flagsindex;

    short	parentindex;
    
    short	posindex;
    
    short quatindex;
    
    short rotindex;
    
    short posetoboneindex;
};

// bone remaps
struct mstudioboneremaptable_t
{
    for(i = 0; i < hdr.numboneremaps; i++)
        ubyte bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
};


//===============
// Hitbox Structs


enum <short> hboxgroup_v16
{
    aGeneric = 0,
    aHead = 1,
    aChest = 2,
    aStomach = 3,
    aLeft_Arm = 4,
    aRight_Arm = 5,
    aLeft_Leg = 6,
    aRight_Leg = 7,
    aNeck = 8
};


// hitbox sets
struct mstudiohitboxset_t_v16
{
    short sznameindex <read=ReadString(startof(this) + this)>;

    short numhitboxes;
    short hitboxindex;
};

// hit box boxes
struct mstudiobbox_t_v54
{
    int bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
    hboxgroup group; // intersection group

    Vector bbmin; // bounding box
    Vector bbmax;	

    int szhitboxnameindex <read=ReadString(startof(this) + this - 32)>; // offset to the name of the hitbox.
    
    int critoverride; // overrides the group to be a crit, 0 or 1. might be group override since group 1 is head.

    int keyvalueindex <read=ReadString(startof(this) + this - 40)>; // used for keyvalues, most for titans.
};

struct mstudiobbox_t_v16
{
    short bone <read=ReadString(startof(bones[this]) + bones[this].sznameindex)>;
    hboxgroup_v16 group; // intersection group

    Vector bbmin; // bounding box
    Vector bbmax;	

    unsigned short szhitboxnameindex <read=ReadString(startof(this) + this - 28)>; // offset to the name of the hitbox.

    unsigned short keyvalueindex <read=ReadString(startof(this) + this - 30)>; // used for keyvalues, most for titans.
};


//==================
// Animation Structs


// anim descriptions
struct mstudioanimdesc_t_v54
{
    int baseptr;

    int sznameindex <read=ReadString(startof(parentof(this)) + this)>;

    float fps; // frames per second	
    int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

    int numframes;

    // piecewise movement
    int nummovements;
    int movementindex;

    int framemovementindex; // new in v52

    int animindex; // non-zero when anim data isn't in sections

    int numikrules;
    int ikruleindex; // non-zero when IK data is stored in the mdl

    int sectionindex;
    int sectionframes; // number of frames used in each fast lookup section, zero if not used
};

// rseq v7.1
struct mstudioanimdesc_t_v54_v121
{
    int baseptr;

    int sznameindex <read=ReadString(startof(parentof(this)) + this)>;

    float fps; // frames per second	
    int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

    int numframes;

    // piecewise movement
    int nummovements;
    int movementindex;

    int framemovementindex; // new in v52

    int animindex; // non-zero when anim data isn't in sections

    int numikrules;
    int ikruleindex; // non-zero when IK data is stored in the mdl

    int sectionindex;
    int sectionstaticframes; // number of static frames inside the animation, the reset excluding the final frame are stored externally. when external data is not loaded(?)/found(?) it falls back on the last frame of this as a stall
    int sectionframes; // number of frames used in each fast lookup section, zero if not used

    int unk1[4]; // is this even real?

    //int unk1; // Padding
    //int unk2; // Padding
    //int unk3; // SomeDataOffset
    //int unk4; // SomeDataOffset

    // it seems like there's another int here but I'm unsure
};

struct mstudioanimdesc_t_v16
{
    float fps; // frames per second	
    int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

    int numframes;

    short sznameindex <read=ReadString(startof(parentof(this)) + this)>;    

    unsigned short framemovementindex; // new in v52

    int animindex; // non-zero when anim data isn't in sections

    short numikrules;
    unsigned short ikruleindex; // non-zero when IK data is stored in the mdl

    int64 unk2;
	uint16 unk1;

    short sectionindex;
    short sectionstallframes; // number of static frames inside the animation, the reset excluding the final frame are stored externally. when external data is not loaded(?)/found(?) it falls back on the last frame of this as a stall
    short sectionframes; // number of frames used in each fast lookup section, zero if not used
};

struct mstudioanimsections_t_v54_v121
{
    int animindex;
    int isExternal; // 0 or 1, if 1 section is not in rseq (I think)
};

// fix index for external stuff
int ReadSectionIndex(int index)
{
    local int realIndex = 0;

    if(index < 0)
        realIndex = Abs(index) - 1;
    else
        realIndex = index;

    return realIndex;
};

struct mstudioanimsections_t_v16
{
    int animindex;  // negative number if external
};

struct sectionindexes_t_v54_v121
{
    mstudioanimsections_t_v54_v121 sectionoffsets[(animdesc[i].numframes / animdesc[i].sectionframes) + 2] <bgcolor=cLtBlue>;
};

struct animflagarray_t_v54
{   
    // don't think this is correct
    byte STUDIO_ANIM_POS_54 : 1;
    byte STUDIO_ANIM_ROT_54 : 1;
    byte STUDIO_ANIM_SCALE_54 : 1;
    byte STUDIO_ANIM_UNK_54 : 1;    
};

// flags for the per bone array, in 4 bit sections (two sets of flags per byte)
//#define STUDIO_ANIM_POS		0x1 // animation has pos values
//#define STUDIO_ANIM_ROT		0x2	// animation has rot values
//#define STUDIO_ANIM_SCALE	0x4	// animation has scale values

struct boneflagarray_t
{

    BitfieldDisablePadding();
    animflagarray_t_v54 boneflag[hdr.numbones] <bgcolor=0xaa8822, optimize=false>;
    BitfieldEnablePadding();
    
    if(hdr.numbones % 4)
        byte padd[(4 - (hdr.numbones % 4)) / 2] <bgcolor=0xaaaa22>;
};

// for rseq templates because no hdr
struct boneflagarray_t_loose
{
    BitfieldDisablePadding();
    animflagarray_t_v54 boneflag[numbones] <bgcolor=0xaa8822, optimize=false>;
    BitfieldEnablePadding();

    if(numbones % 4)
        byte padd[(4 - (numbones % 4)) / 2] <bgcolor=0xaaaa22>;
};


#define STUDIO_ANIMPTR_Z 0x01 // mstudioanimvalue_t
#define STUDIO_ANIMPTR_Y 0x02 // mstudioanimvalue_t
#define STUDIO_ANIMPTR_X 0x04 // mstudioanimvalue_t

string ReadAnimPtrFlagsV54(byte flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    byte flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case STUDIO_ANIMPTR_X:
            value += "STUDIO_ANIMPTR_X";
            break;
        case STUDIO_ANIMPTR_Y:
            value += "STUDIO_ANIMPTR_Y";
            break;
        case STUDIO_ANIMPTR_Z:
            value += "STUDIO_ANIMPTR_Z";
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

// to get mstudioanim_value_t for each axis:
// if 1 flag, only read from offset
// if 2 flags (e.g. y,z):
// y @ offset;
// z @ offset + (idx1 * sizeof(mstudioanimvalue_t));

// if 3 flags:
// x @ offset;
// y @ offset + (idx1 * sizeof(mstudioanimvalue_t));
// z @ offset + (idx2 * sizeof(mstudioanimvalue_t));
struct mstudioanim_valueptr_t_v54
{
    short offset : 13;
    short flags : 3 <read=ReadAnimPtrFlagsV54>;
    unsigned char axisIdx1; // these two are definitely unsigned
    unsigned char axisIdx2; 
};

#define STUDIO_ANIM_ANIMSCALE_54 0x01 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMROT_54	 0x02 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMPOS_54	 0x04 // mstudioanim_valueptr_t

/*// flags for the actually per bone animation headers
// "mstudioanim_valueptr_t" indicates it has a set of offsets into anim tracks
#define STUDIO_ANIM_ANIMSCALE	0x01 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMROT		0x02 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMPOS		0x04 // mstudioanim_valueptr_t*/

string ReadAnimFlagsV54(byte flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    byte flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 8; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case STUDIO_ANIM_ANIMSCALE_54:
            value += "STUDIO_ANIM_ANIMSCALE_54";
            break;
        case STUDIO_ANIM_ANIMROT_54:
            value += "STUDIO_ANIM_ANIMROT_54";
            break;
        case STUDIO_ANIM_ANIMPOS_54:
            value += "STUDIO_ANIM_ANIMPOS_54";
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

struct mstudio_rle_anim_t_v54
{

    short size : 13; // total size of all animation data, not next offset because even the last one has it

    short flags : 3 <read=ReadAnimFlagsV54(this)>;
    
    if(flags & STUDIO_ANIM_ANIMPOS_54)
        float posscale;

    if(flagarray.boneflag[j].STUDIO_ANIM_POS_54)
    {
        if(flags & STUDIO_ANIM_ANIMPOS_54)
            mstudioanim_valueptr_t_v54 animpos;
        else
            Vector48 rawpos;
    }

    if(flagarray.boneflag[j].STUDIO_ANIM_ROT_54)
    {
        if(flags & STUDIO_ANIM_ANIMROT_54)
            mstudioanim_valueptr_t_v54 animrot;
        else
            Quaternion64	rawrot;
    }

    if(flagarray.boneflag[j].STUDIO_ANIM_SCALE_54)
    {
        if(flags & STUDIO_ANIM_ANIMSCALE_54)
            mstudioanim_valueptr_t_v54 animscale;
        else
            Vector48 rawscale;
    }
};

// apex ikerrors do the same thing as apex framemovements
struct mstudiocompressedikerror_t_v54
{
    float scale[6]; // these values are the same as what posscale (if it was used) and rotscale are.
    int sectionframes; // frames per section, may not match animdesc
};

struct mstudiocompressedikerror_t_v16
{
    short sectionframes; // frames per section, may not match animdesc
    float scale[6]; // these values are the same as what posscale (if it was used) and rotscale are.
};

// basically compressedikerrors and frame movements will have an array of offsets that leads into the traditional 'short offset' array, allowing it to have per section (if the anim uses sections) data
struct mstudioframemovement_t_v54
{
    float scale[4]; // first three values are the same as what posscale (if it was used) is, fourth is similar to unkvector1.
    int sectionframes; // frames per section, may not match animdesc
                       // may have more than one, even when not section anim
};

struct mstudioikrule_t_v54
{
    int index;
    int type <read=ReadIKRuleType(this)>;
    int chain;
    int bone; // gets it from ikchain now pretty sure

    int slot; // iktarget slot. Usually same as chain.
    float height;
    float radius;
    float floor;
    Vector pos;
    Quaternion q;

    // apex does this oddly
    mstudiocompressedikerror_t_v54 compressedikerror;
    int compressedikerrorindex;

    int iStart;
    int ikerrorindex;

    float start; // beginning of influence
    float peak; // start of full influence
    float tail; // end of full influence
    float end; // end of all influence

    float contact; // frame footstep makes ground concact
    float drop; // how far down the foot should drop when reaching for IK
    float top; // top of the foot box

    int szattachmentindex; // name of world attachment

    float endHeight; // new in v52   
};

struct mstudioikrule_t_v16
{
    short index;
    short bone;
    byte type <read=ReadIKRuleType(this)>;
    byte slot; // chain/slot merged?

    // whar the heck
    mstudiocompressedikerror_t_v16 compressedikerror;
    int compressedikerrorindex;

    short iStart;
    short ikerrorindex;

    float start; // beginning of influence
    float peak; // start of full influence
    float tail; // end of full influence
    float end; // end of all influence

    float contact; // frame footstep makes ground concact
    float drop; // how far down the foot should drop when reaching for IK
    float top; // top of the foot box

    //char placeholder[44];

    // if both of these ints become shorts then it would fit

    // ORDER BELOW UNKNOWN

    // cut now?
    //unsigned short szattachmentindex; // name of world attachment

    float endHeight; // new in v52, bt uses this I think

    // this fits but I don't really know
    //short slot; // iktarget slot. Usually same as chain.
    float height;
    float radius;
    float floor;
    Vector pos;
    Quaternion q;
};

// seq descriptions
struct mstudioseqdesc_t_v54
{
    int baseptr;

    int	szlabelindex <read=ReadString(startof(this) + this - 4)>;

    int szactivitynameindex <read=ReadString(startof(this) + this - 8)>;

    int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

    int activity; // initialized at loadtime to game DLL values
    int actweight;

    int numevents;
    int eventindex;
    
    Vector bbmin; // per sequence bounding box
    Vector bbmax;		

    int numblends;

    // Index into array of shorts which is groupsize[0] x groupsize[1] in length
    int animindexindex;

    int movementindex; // [blend] float array for blended movement
    int groupsize[2];
    int paramindex[2]; // X, Y, Z, XR, YR, ZR
    float paramstart[2]; // local (0..1) starting value
    float paramend[2]; // local (0..1) ending value
    int paramparent;

    float fadeintime; // ideal cross fate in time (0.2 default)
    float fadeouttime; // ideal cross fade out time (0.2 default)

    int localentrynode; // transition node at entry
    int localexitnode; // transition node at exit
    int nodeflags; // transition rules

    float entryphase; // used to match entry gait
    float exitphase; // used to match exit gait
    
    float lastframe; // frame that should generation EndOfSequence

    int nextseq; // auto advancing sequences
    int pose; // index of delta animation between end and nextseq

    int numikrules;

    int numautolayers;
    int autolayerindex;

    int weightlistindex;

    int posekeyindex;

    int numiklocks;
    int iklockindex;

    // Key values
    int keyvalueindex;
    int keyvaluesize;

    int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
    int numactivitymodifiers;

    int ikResetMask; // new in v52
    int unk1;

    int unkindex;
    int unkcount;
};

struct mstudioseqdesc_t_v16
{
    short szlabelindex <read=ReadString(startof(this) + this)>;

    short szactivitynameindex <read=ReadString(startof(this) + this - 2)>;

    int flags <read=ReadAnimDescFlags(this)>; // looping/non-looping flags

    short activity; // initialized at loadtime to game DLL values
    short actweight;

    short numevents;
    short eventindex;
    
    Vector bbmin; // per sequence bounding box
    Vector bbmax;		

    short numblends;

    // Index into array of shorts which is groupsize[0] x groupsize[1] in length
    short animindexindex;

    //short movementindex; // [blend] float array for blended movement
    short paramindex[2]; // X, Y, Z, XR, YR, ZR
    float paramstart[2]; // local (0..1) starting value
    float paramend[2]; // local (0..1) ending value
    //short paramparent;

    float fadeintime; // ideal cross fate in time (0.2 default)
    float fadeouttime; // ideal cross fade out time (0.2 default)

    short localentrynode; // transition node at entry
    short localexitnode; // transition node at exit

    short numikrules;

    short numautolayers;
    unsigned short autolayerindex;

    unsigned short weightlistindex;

    byte groupsize[2];

    unsigned short posekeyindex;

    short numiklocks;
    short iklockindex;

    // Key values
    unsigned short unk_5C;

    short cycleposeindex; // index of pose parameter to use as cycle index

    short activitymodifierindex;
    short numactivitymodifiers;

    int ikResetMask; // new in v52
    int unk1;

    unsigned short unkindex;
    short unkcount;
};

struct mstudioautolayer_t_v54
{
    // this needs to have a guid descriptor in rpak
    __int64 guidSequence <read=Str("%s - %LX", "aseq", this)>; // hashed aseq guid asset

    short iSequence; // only used within an rmdl I would imagine
    short iPose;

    int flags <read=ReadAutoLayerFlags(this)>;
    float start;	// beginning of influence
    float peak;	// start of full influence
    float tail;	// end of full influence
    float end;	// end of all influence
};

struct mstudioevent_t_v54
{
    float cycle;
    int	event;
    int type <read=ReadEventFlags(this)>; // this will be 0 if old style I'd imagine
    char options[256];

    int szeventindex <read=ReadString(startof(this) + this - 268)>;
};

// rseq v10
struct mstudioevent_t_v54_v122
{
    float cycle;
    int	event;
    int type <read=ReadEventFlags(this)>; // this will be 0 if old style I'd imagine

    int unk; // 2, 4, animseq/weapons/crypto_heirloom/ptpov_sword_crypto/draw.rseq

    char options[256]; // this is the only difference compared to normal v54

    int szeventindex <read=ReadString(startof(this) + this - 272)>;
};

struct mstudioevent_t_v16
{
    float cycle;
    int	event;
    int type <read=ReadEventFlags(this)>; // this will be 0 if old style I'd imagine

    int unk;

    short szoptionsindex <read=ReadString(startof(this) + this - 16)>;

    short szeventindex <read=ReadString(startof(this) + this - 18)>;
};

struct mstudioactivitymodifier_t_v16
{	
    short sznameindex <read=ReadString(startof(this) + this)>;

    bool negate; // 0 or 1 observed.
};

// wraith_menu_select.rseq
// caustic_gladcard_animated_hunting.rseq
// caustic_gladcard_animated_coffee.rseq
struct unkseqdata_t
{
    // generally 0-1
    float unkfloat;

    int unk;

    // quaternion mayhaps
    float unkfloat1;
    float unkfloat2;
    float unkfloat3;
    float unkfloat4;
};

// pose parameter desc
struct mstudioposeparamdesc_t_v16
{
    unsigned short sznameindex <read=ReadString(startof(this) + this)>;

    short flags; // ????
    float start; // starting value
    float end; // ending value
    float loop;	// looping range, 0 for no looping, 360 for rotations, etc.
};

//===================
// Model/Mesh Structs


// bodyparts
struct mstudiobodyparts_t_v54_v15
{
    int sznameindex <read=ReadString(startof(this) + this)>;
    int nummodels;
    int base;
    int modelindex; // index into models array

    int unk;
    int meshindex; // start of meshes?
};

struct mstudiobodyparts_t_v16
{
    short sznameindex <read=ReadString(startof(this) + this)>;
    short modelindex;
    int base;
    int nummodels;
    int meshindex; // might be short
};

// studio models
struct mstudiomodel_t_v54
{
    char name[64];

    int unkindex2 <read=ReadString(startof(this) + this - 64)>; // goes to bones sometimes, string index

    int type;

    float boundingradius;

    int nummeshes;	
    int meshindex;

    // cache purposes
    int numvertices; // number of unique vertices/normals/texcoords
    int vertexindex; // vertex Vector
    int tangentsindex; // tangents Vector

    int numattachments;
    int attachmentindex;

    int deprecated_numeyeballs;
    int deprecated_eyeballindex;

    int pad[4];

    int colorindex; // vertex color
                    // offset by colorindex number of bytes into vvc vertex colors
    int uv2index; // vertex second uv map
                  // offset by uv2index number of bytes into vvc secondary uv map
};

struct mstudiomodel_t_v54_v121
{
    char name[64];

    int unkindex2 <read=ReadString(startof(this) + this - 64)>; // byte before string block

    // it looks like they write the entire name
    // then write over it with other values where needed
    // why.
    int type;

    float boundingradius;

    int nummeshes;	
    int meshindex;

    // cache purposes
    int numvertices; // number of unique vertices/normals/texcoords
    int vertexindex; // vertex Vector
    int tangentsindex; // tangents Vector

    int numattachments;
    int attachmentindex;

    int colorindex; // vertex color
                    // offset by colorindex number of bytes into vvc vertex colors
    int uv2index; // vertex second uv map
                  // offset by uv2index number of bytes into vvc secondary uv map
};

struct mstudiomodel_t_v54_v13
{
    char name[64];

    int unkindex2 <read=ReadString(startof(this) + this - 64)>; // byte before string block

    // it looks like they write the entire name
    // then write over it with other values where needed
    // why.
    int type;

    float boundingradius;

    int nummeshes;	
    int meshindex;

    // cache purposes
    int numvertices; // number of unique vertices/normals/texcoords
    int vertexindex; // vertex Vector
    int tangentsindex; // tangents Vector

    int numattachments;
    int attachmentindex;

    int colorindex; // vertex color
                    // offset by colorindex number of bytes into vvc vertex colors
    int uv2index; // vertex second uv map
                  // offset by uv2index number of bytes into vvc secondary uv map

    int unk; // same as uv2index, did they add something to vvc/0tVG?
};

struct mstudiomodel_t_v54_v14
{
    char name[64];

    int unkindex2 <read=ReadString(startof(this) + this - 64)>; // byte before string block

    // they write over these two when it's the default
    int type;

    float boundingradius;

    int nummeshes;	

    // first is the same as nummeshes?
    int unk_v14;
    int unk1_v14;

    int meshindex;

    // most of these vtx, vvd, vvc, and vg indexes are depreciated after v14.1 (s14)

    // cache purposes
    int numvertices; // number of unique vertices/normals/texcoords
    int vertexindex; // vertex Vector
    int tangentsindex; // tangents Vector

    int numattachments;
    int attachmentindex;

    int colorindex; // vertex color
    int uv2index; // vertex second uv map
    int unk;
};

struct mstudiomodel_t_v16
{

    short unkindex2 <read=ReadString(startof(this) + this)>;

    short nummeshes;	

    // first is the same as nummeshes?
    short unk_v14;
    short unk1_v14;

    short meshindex;
};

// meshes
struct mstudiomesh_t_v54
{
    int material <read=ReadString(startof(textures[this]) + textures[this].sznameindex)>;

    int modelindex;

    int numvertices; // number of unique vertices/normals/texcoords
    int vertexoffset; // vertex mstudiovertex_t

    // Access thin/fat mesh vertex data (only one will return a non-NULL result)
    
    int deprecated_numflexes; // vertex animation
    int deprecated_flexindex;

    // special codes for material operations
    int deprecated_materialtype;
    int deprecated_materialparam;

    // a unique ordinal for this mesh
    int meshid;

    Vector center;

    mstudio_meshvertexloddata_t vertexloddata;
    
    char unk[8]; // these are suposed to be filled on load, however this isn't true??
};

struct mstudiomesh_t_v54_v121
{
    int material <read=ReadString(startof(textures[this]) + textures[this].sznameindex)>;

    int modelindex;

    int numvertices; // number of unique vertices/normals/texcoords
    int vertexoffset; // vertex mstudiovertex_t
    
    // a unique ordinal for this mesh
    int meshid;

    Vector center;

    // depreciated in later versions?
    mstudio_meshvertexloddata_t vertexloddata;
    
    char unk[8]; // these are suposed to be filled on load, however this isn't true??
};

struct mstudiomesh_t_v16
{
    short material;

    // a unique ordinal for this mesh
    short meshid;

    byte unk[4];

    Vector center;
};


//=================
// Material Structs


// skin info
struct mstudiotexture_t_v54
{
    int sznameindex <read=ReadString(startof(this) + this)>;

    __int64 guid <read=Str("%s - %LX", "matl", this)>; // guid of the material it references
};

struct mstudiotexture_t_v16
{
    __int64 guid <read=Str("%s - %LX", "matl", this)>;
};

// texture types, new in v54
enum <byte> MaterialShaderType_t
{
  RGDU = 0x0,
  RGDP = 0x1,
  RGDC = 0x2,
  SKNU = 0x3,
  SKNP = 0x4,
  SKNC = 0x5,
  WLDU = 0x6,
  WLDC = 0x7,
  PTCU = 0x8,
  PTCS = 0x9,
};


//====
// RUI


// not actually fourth vert wtf??
struct mstudioruifourthvertv54_t
{
    // -1 if unused, dedicated slot for fourth vert
    byte vertextra;
    byte vertextra1;
};

struct mstudioruimesh_t_v54
{
    short numparents; // apparently you can have meshes parented to more than one bone(?)
    short numvertices; // number of verts
    short numfaces; // number of faces (quads)

    short unk; // num uvs? or this is num faces and current num faces is num uvs

    int parentindex; // this gets padding out front of it to even off the struct

    int vertexindex; // offset into smd style vertex data
    int unkindex;
    int vertmapindex; // offsets into a vertex map for each quad
    int facedataindex; // offset into uv section
};


//========
// Unknown

struct mstudiocollmodel_t
{
    int contentMasksIndex;
    int surfacePropsIndex;
    int surfaceNamesIndex;
    int headerCount;
};

struct mstudiocollheader_t
{
    int unk;
    int bvhNodeIndex;
    int vertIndex;
    int bvhLeafIndex;
    float unk_10[3];
    char unk_1C[4];
};

struct mstudiocollheader_t_v12
{
    int unk;
    int bvhNodeIndex;
    int vertIndex;
    int bvhLeafIndex;
    int unkIndex;
    int unkNew;

    float unk_10[3];
    char unk_1C[4];
};

// for bvh4 types:
// 0 bvh4 node
// 1 no children
// 3 on flyer
// 5 on most models
// 7 on flyer

// PACKED - uses "packed" vertex values stored in 3 16-bit integers and scaled at runtime to correct value
// UNPACKED - uses a regular float3 vector for storing vertex position
string ReadBVHChildType(byte flags)
{
    string value = "";


    switch(flags)
    {
    case 0:
        value += "NODE (0)";
        break;
    case 1:
        value += "NO_CHILD (1)";
        break;
    case 3:
        value += "UNK_ON_FLYER_1 (3)";
        break;
    case 4: 
        // used for triangles in bsp collision mesh and large models
        // where verts exceed limits of packed verts
        value += "TRI (4)"; 
        break;
    case 5:
        value += "PACKED_TRI (5)";
        break;
    case 6:
        // used for quads in bsp collision mesh and large models
        // where verts exceed limits of packed verts
        value += "QUAD (6)";
        break;
    case 7:
        value += "PACKED_QUAD (7)";
        break;
    default:
        value += Str("UNK_%x", flag);
        break;
    }

    return value;
}

struct CollTri_t
{
    int vert1offset : 11;
    int vert2offset : 9;
    int vert3offset : 9;
    int edgeMask    : 3;
};

struct CollPackedTriLeaf_t
{
    int unk : 12;
    int highestTriIndex : 4; // numTris = highestTriIndex + 1;

    // vertex start offset for this leaf's verts: unk_2 << 10
    // index into vertex buffer
    int vertStartOffset : 16 <read=Str("%i", this << 10)>;
};

struct BVH4Axis_t
{
    short minChild0;
    short maxChild0;

    short minChild1;
    short maxChild1;

    short minChild2;
    short maxChild2;

    short minChild3;
    short maxChild3;
};

struct BVH4Node_t
{
    BVH4Axis_t x;
    BVH4Axis_t y;
    BVH4Axis_t z;

    int pad : 8;
    int index0 : 24; 

    int collision_mask : 8;
    int index1 : 24; 

    int child0_type : 4 <read=ReadBVHChildType(this)>; 
    int child1_type : 4 <read=ReadBVHChildType(this)>;
    int index2 : 24;

    int child2_type : 4 <read=ReadBVHChildType(this)>; 
    int child3_type : 4 <read=ReadBVHChildType(this)>;
    int index3 : 24;
};


//========
// VG Data


// lod related maybe
// look at hsprays for weird lods and confirmation on some of these vars
struct ModelLODHeader_RMDL_t
{
    short lodLevel;

    short headerIndex; // has to do with the vg header? lod index?

    //Mesh array
    short meshOffset;
    short numMeshes;

    float switchPoint;

    int pad; // not actually part of this struct, needs to be fixed
};

struct vgHeaderData_t
{
    int dataOffset; // offset to this section in vg
    int dataSize; // size of data in vg

    // this could also be vg section index
    short lodLevel; // 0, 1, 2, 3, etc
    short numLODs; // normally 1, stolen from vg structs. lods based off this header

    short numUnknown; // powers of two

    short pad;
};

struct vgHeaderData_t_v16
{
    int dataOffset; // offset to this section in compressed vg
    int dataSizeCompressed; // compressed size of data in vg
    int dataSizeDecompressed; // decompressed size of data in vg

    byte unk;

    // this could also be vg section index
    byte lodLevel; // 0, 1, 2, 3, etc
    byte numLODs; // normally 1, stolen from vg structs. lods based off this header

    byte numUnknown; // powers of two
};


struct vgmesh_t
{
    int unk[2];

    float unkfloat;

    int unk1[9];
};


//=====
// Misc

int popCount(int x)
{
    local int count = 0;
    while (x)
    {
        count += x & 1;
        x >>= 1;
    }
    return count;
}

struct animmetadata_t {
    local float color = gl_mainColor[gl_xyz];
    ubyte type; //0: signed 16bit perframe value
                //1: 8bit integer add up previous frame value
                //else: complex compression
    ubyte total;
};

void writeAnimvalue(short &f, string value){
    f = Atof(value) * 256;
}

struct animvalue_t{
    animmetadata_t metadata <read=Str("%d/%d", type, total), fgcolor=color>;
    
    Printf("%d/%d\n", flagcount, finaldatasize[flagcount]);
    short data[finaldatasize[flagcount]]<read=Str("%d",(short)(this)),write=writeAnimvalue> ;//1.198459e-05
    flagcount ++;
};

void acquiringdatasize(mstudioanim_valueptr_t_v54 &hdr_anim){
    valueOffset = startof(hdr_anim) + (hdr_anim.offset);
    FSeek(valueOffset);
    if(hdr_anim.flags & STUDIO_ANIMPTR_X) 
        datasize[flagcount--] = FTell() + 2;
    FSeek(valueOffset + (hdr_anim.axisIdx1 * sizeof(mstudioanimvalue_t)));
    if(hdr_anim.flags & STUDIO_ANIMPTR_Y) 
        datasize[flagcount--] = FTell() + 2;
    FSeek(valueOffset + (hdr_anim.axisIdx2 * sizeof(mstudioanimvalue_t)));
    if(hdr_anim.flags & STUDIO_ANIMPTR_Z) 
        datasize[flagcount--] = FTell() + 2;
}
                                        